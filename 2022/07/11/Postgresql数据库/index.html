
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Postgresql数据库 | Harvch( ‘-ωก̀ )です</title>
        <meta name="author" content="Harvch">
        <meta name="description" content="">
        <meta name="keywords" content="">
        <link rel="icon" href="https://avatars.githubusercontent.com/u/93763322?s=96&v=4">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
		<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Harvch( ‘-ωก̀ )です</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Harvch( ‘-ωก̀ )です</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1>Postgresql数据库 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/7/11
        </span>
        
        <span class="category">
            <a href="/categories/数据库">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                </span>
                数据库
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
            </span>
            
            <span class="tag">
                
                <a href="/tags/sql" style="color: #ffa2c4">
                    sql
                </a>
            </span>
            
        </span>
        
    </div>
    <div class="content" v-pre>
        <p>Postgresql数据库是关系型数据库</p>
<p>下载地址： <a target="_blank" rel="noopener" href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</a></p>
<span id="more"></span>

<p><strong>WITH 查询</strong></p>
<p>​	WITH查询是PostgreSQL支持的高级SQL特性之一，这一特性常称为CTE(Common Table Expressions)，WITH查询在复杂查询中定义一个辅助语句（可理解成在一个查询中定义的临时表），这一特性常用于复杂查询或递归查询应用场景</p>
<pre><code class="sql">with a as (select * from wp_dkbasedatainfo where xzqdm =&#39;650203&#39; )
select * from a ,b where a.tbflqk=&#39;实地伪变化&#39;
</code></pre>
<p>​	WITH 查询的一个重要属性是 RECURSIVE，使用 RECURSIVE 属性可以引用自己的输出，从而实现递归，一般用于层次结构或树状结构的应用场景</p>
<p>例如，存在一张包含如下数据的表：</p>
<pre><code class="sql">id name fatherid1 中国 02 辽宁 13 山东 14 沈阳 25 大连 26 济南 37 和平区 48 沈河区 4
</code></pre>
<p>使用PostgreSQL的WITH查询检索ID为7以及以上的所有父节点，如下：</p>
<pre><code class="sql">WITH RECURSIVE r AS ( 
SELECT * FROM test_area WHERE id = 7 UNION ALL SELECT test_area.* FROM test_area, r WHERE test_area.id = r.fatherid 
) 
SELECT * FROM r ORDER BY id;
</code></pre>
<p>查询结果如下：</p>
<pre><code class="sql">id | name | fatherid----+--------+---------- 1 | 中国 | 0 2 | 辽宁 | 1 4 | 沈阳 | 2 7 | 和平区 | 4(4 rows)
</code></pre>
<p><strong>WITH RECURSIVE</strong></p>
<p>WITH 语句还可以通过增加 RECURSIVE 修饰符来引入它自己，从而实现递归</p>
<p>WITH RECURSIVE 一般用于处理逻辑上层次化或树状结构的数据，典型的使用场景是寻找直接及间接子结点</p>
<p>定义下面这样的表，存储每个区域（省、市、区）的 id，名字及上级区域的 id</p>
<pre><code class="sql">CREATE TABLE chinamap
(
  id INTEGER,
  pid INTEGER,
  name TEXT
);
</code></pre>
<p>需要查出某个省，比如湖北省，管辖的所有市及市辖地区，可以通过WITH RECURSIVE来实现，如下：</p>
<pre><code class="sql">WITH RECURSIVE result AS
(
  SELECCT
    id,
    name
  FROM  chinamap
  WHERE id = 11
  UNION ALL
  SELECT
    origin.id,
    result.name || &#39; &gt; &#39; || origin.name
  FROM result
  JOIN chinamap origin
  ON origin.pid = result.id
)
SELECT
  id,
  name
FROM result;
</code></pre>
<p>结果如下：</p>
<pre><code class="sql"> id  |           name           
-----+--------------------------
  11 | 湖北省
 110 | 湖北省 &gt; 武汉市
 120 | 湖北省 &gt; 孝感市
 130 | 湖北省 &gt; 宜昌市
 140 | 湖北省 &gt; 随州市
 150 | 湖北省 &gt; 仙桃市
 160 | 湖北省 &gt; 荆门市
 170 | 湖北省 &gt; 枝江市
 180 | 湖北省 &gt; 神农架市
 111 | 湖北省 &gt; 武汉市 &gt; 武昌区
 112 | 湖北省 &gt; 武汉市 &gt; 下城区
 113 | 湖北省 &gt; 武汉市 &gt; 江岸区
 114 | 湖北省 &gt; 武汉市 &gt; 江汉区
 115 | 湖北省 &gt; 武汉市 &gt; 汉阳区
 116 | 湖北省 &gt; 武汉市 &gt; 洪山区
 117 | 湖北省 &gt; 武汉市 &gt; 青山区
(16 rows)  
</code></pre>
<p><strong>WITH RECURSIVE 执行过程</strong></p>
<p>从上面的例子可以看出，WITH RECURSIVE语句包含了两个部分</p>
<ul>
<li>non-recursive term（非递归部分），即上例中的union all前面部分</li>
<li>recursive term（递归部分），即上例中union all后面部分</li>
</ul>
<p>执行步骤如下：	</p>
<ol>
<li>执行non-recursive term（如果使用的是union而非union all，则需对结果去重）其结果作为recursive term中对result的引用，同时将这部分结果放入临时的working table中</li>
<li>重复执行如下步骤，直到working table为空：用working table的内容替换递归的自引用，执行recursive term，（如果使用union而非union all，去除重复数据），并用该结果（如果使用union而非union all，则是去重后的结果）替换working table</li>
</ol>
<p>以上面的query为例，来看看具体过程：</p>
<p>1.执行：</p>
<pre><code class="sql">SELECT  id,  nameFROM chinamapWHERE id = 11
</code></pre>
<p>结果集和 working table 为：</p>
<pre><code class="sql">11 | 湖北              
</code></pre>
<p>2.执行：</p>
<pre><code class="sql">SELECT
  origin.id,
  result.name || &#39; &gt; &#39; || origin.name
FROM result
JOIN chinamap origin
ON origin.pid = result.id
</code></pre>
<p>结果集和 working table 为：</p>
<pre><code class="sql">110 | 湖北省 &gt; 武汉市
120 | 湖北省 &gt; 孝感市
130 | 湖北省 &gt; 宜昌市
140 | 湖北省 &gt; 随州市
150 | 湖北省 &gt; 仙桃市
160 | 湖北省 &gt; 荆门市
170 | 湖北省 &gt; 枝江市
180 | 湖北省 &gt; 神农架市
</code></pre>
<p>3.再次执行recursive query，结果集和working table为：   </p>
<pre><code class="sql">111 | 湖北省 &gt; 武汉市 &gt; 武昌区
112 | 湖北省 &gt; 武汉市 &gt; 下城区
113 | 湖北省 &gt; 武汉市 &gt; 江岸区
114 | 湖北省 &gt; 武汉市 &gt; 江汉区
115 | 湖北省 &gt; 武汉市 &gt; 汉阳区
116 | 湖北省 &gt; 武汉市 &gt; 洪山区
117 | 湖北省 &gt; 武汉市 &gt; 青山区
</code></pre>
<p>4.继续执行recursive query，结果集和working table为空</p>
<p>5.结束递归，将前三个步骤的结果集合并，即得到最终的WITH RECURSIVE的结果集严格来讲，这个过程实现上是一个迭代的过程而非递归，不过RECURSIVE这个关键词是SQL标准委员会定立的，所以PostgreSQL也延用了RECURSIVE这一关键词</p>
<p><strong>WITH RECURSIVE 防止死循环</strong></p>
<p>​	从上一节中可以看到，决定是否继续迭代的working table是否为空，如果它永不为空，则该CTE将陷入无限循环中</p>
<p>对于本身并不会形成循环引用的数据集，无段作特别处理而对于本身可能形成循环引用的数据集，则须通过SQL处理</p>
<p>​	一种方式是使用UNION而非UNION ALL，从而每次recursive term的计算结果都会将已经存在的数据清除后再存入working table，使得working table最终会为空，从而结束迭代</p>
<p>​	然而，这种方法并不总是有效的，因为有时可能需要这些重复数据同时UNION只能去除那些所有字段都完全一样的记录，而很有可能特定字段集相同的记录即应该被删除此时可以通过数组（单字段）或者ROW（多字段）记录已经访问过的记录，从而实现去重的目的</p>
<p><strong>WITH RECURSIVE 求最短路径</strong></p>
<p>定义如下表并存入每条边的权重</p>
<pre><code class="sql">CREATE TABLE graph
(
  id char,
  neighbor char,
  value integer
);
INSERT INTO graph
VALUES(&#39;A&#39;, &#39;B&#39;, 3),
(&#39;A&#39;, &#39;C&#39;, 5),
(&#39;A&#39;, &#39;D&#39;, 4),
(&#39;B&#39;, &#39;E&#39;, 8),
(&#39;B&#39;, &#39;C&#39;, 4),
(&#39;E&#39;, &#39;C&#39;, 7),
(&#39;E&#39;,&#39;F&#39;, 10),
(&#39;C&#39;, &#39;D&#39;, 3),
(&#39;C&#39;, &#39;F&#39;, 6),
(&#39;F&#39;,&#39;D&#39;, 5);   
</code></pre>
<p>计算思路如下：</p>
<ul>
<li>因为是无向图，所以首先要将各条边的id和neighbor交换一次以方便后续计算	</li>
<li>利用WITH RECURSIVE算出所有可能的路径并计算其总权重</li>
<li>因为该图有环，为避免无限循环，同时为了计算路径，将经过的结点存于数据中，当下一个结点已经在数据中时，说明该结点已被计算</li>
<li>最终可算出所有可能的路径及其总权重</li>
</ul>
<p>实现如下：    </p>
<pre><code class="sql"> WITH RECURSIVE edges AS (
  SELECT id, neighbor, value FROM graph
  UNION ALL
  SELECT neighbor, id, value 
  FROM graph
), 
all_path (id, neighbor, value, path, depth, cycle) AS (
  SELECT
    id, neighbor, value, ARRAY[id], 1, &#39;f&#39;::BOOLEAN
  FROM edges
  WHERE id = &#39;A&#39;
  UNION ALL
  SELECT
    all_path.id,
    edges.neighbor,
    edges.value + all_path.value,
    all_path.path || ARRAY[edges.id],
    depth + 1,
    edges.id = ANY(all_path.path)
  FROM edges
  JOIN all_path
  ON all_path.neighbor = edges.id
  AND NOT cycle
), a_f AS (
  SELECT
    rank() over(order by value) AS rank,
    path || neighbor AS path,
    value,
    depth
  FROM all_path
  WHERE neighbor = &#39;F&#39;
)
SELECT path, value, depth
FROM a_f
WHERE rank = 1;
</code></pre>
<p><strong>WITH RECURSIVE 使用限制</strong></p>
<ul>
<li>如果在recursive term中使用LEFT JOIN，自引用必须在“左”边</li>
<li>如果在recursive term中使用RIGHT JOIN，自引用必须在“右”边</li>
<li>recursive term中不允许使用FULL JOIN</li>
<li>recursive term中不允许使用GROUP BY和HAVING</li>
<li>不允许在recursive term的WHERE语句的子查询中使用CTE的名字</li>
<li>不支持在recursive term中对CTE作aggregation</li>
<li>recursive term中不允许使用ORDER BY</li>
<li>LIMIT &#x2F; OFFSET不允许在recursive term中使用</li>
<li>FOR UPDATE不可在recursive term中使用</li>
<li>recursive term中SELECT后面不允许出现引用CTE名字的子查询</li>
<li>同时使用多个CTE表达式时，不允许多表达式之间互相访问（支持单向访问）</li>
<li>在recursive term中不允许使用FOR UPDATE</li>
</ul>
<p><strong>CTE 优缺点</strong></p>
<ul>
<li>可以使用递归 WITH RECURSIVE，从而实现其它方式无法实现或者不容易实现的查询</li>
<li>当不需要将查询结果被其它独立查询共享时，它比视图更灵活也更轻量</li>
<li>CTE只会被计算一次，且可在主查询中多次使用</li>
<li>CTE可极大提高代码可读性及可维护性</li>
<li>CTE不支持将主查询中where后的限制条件push down到CTE中，而普通的子查询支持</li>
</ul>
<p>2.数据库中的数据如果不存在则插入，存在则更新</p>
<pre><code class="sql">INSERT INTO test_postgre(id,name,InputTime,age)
VALUES(&#39;1&#39;,&#39;postgre&#39;,&#39;2018-01-10 22:00:00&#39;,24)
ON conflict(id) 
DO UPDATE SET name = &#39;postgreOk&#39;, InputTime =&#39;2018-02-22 12:00:00&#39;    
</code></pre>
<p><strong>常用 SQL 语句</strong></p>
<pre><code class="sql">-- 如果表中存在了 id 这条数据则更新否则向表中插入数据
INSERT INTO test_postgre(id,name,InputTime,age)
VALUES(&#39;1&#39;,&#39;postgre&#39;,&#39;2018-01-10 22:00:00&#39;,24)
ON conflict(id) 
DO UPDATE SET name = &#39;postgreOk&#39;, InputTime =&#39;2018-02-22 12:00:00&#39;

-- 如果 a.title 为空则取 b.title 的值
select coalesce(a.title,b.title) from a
join b on a.pid = a.id

-- 筛选 title 列为空的数据
select * from a
where a.title is null

-- 筛选 title 列为非空的数据
select * from a
where a.title is not null

-- case when 语句块的使用
select 
(
case 
    when fwxz = &#39;0&#39; then &#39;市场化商品房&#39;
    when fwxz = &#39;1&#39; then &#39;动迁房&#39;
    when fwxz = &#39;2&#39; then &#39;配套商品房&#39;
    when fwxz = &#39;3&#39; then &#39;公共租赁住房&#39;
    when fwxz = &#39;4&#39; then &#39;廉租住房&#39;
    when fwxz = &#39;5&#39; then &#39;限价普通商品住房&#39;
    when fwxz = &#39;6&#39; then &#39;经济适用住房&#39;
    when fwxz = &#39;7&#39; then &#39;定销商品房&#39;
    when fwxz = &#39;8&#39; then &#39;集资建房&#39;
    when fwxz = &#39;9&#39; then &#39;福利房&#39;
    when fwxz = &#39;10&#39; then &#39;保障性住房&#39;
    when fwxz = &#39;11&#39; then &#39;房改房&#39;
    when fwxz = &#39;12&#39; then &#39;自建房&#39;
    when fwxz = &#39;99&#39; then &#39;其它&#39;
    else fwxz
end
) as fwxz,count(*)
from fwb_qjcg_hb
group by fwxz

-- 查询时去除重复的数据
select distinct name,phone from user

-- 更新返回更新后列的数据
update &quot;user&quot; set 	username = &#39;aa&#39; returning username

-- 插入表中某列的数据返回插入后的数据
insert into &quot;user&quot;(username) values(&#39;张三&#39;) returning username

-- unnest 函数将输入的数组转换成一个表,这个表的每一列都代表相应的一个数组中的元素
select &#39;张三&#39; as name ,unnest(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) as course

-- with ordinality 用于给返回的结果集增加一个整数列，这个整数列从1开始，并且按1递增
-- 注： with ordinality 必须使用在from子句中，且要紧跟在函数后面使用！
select * from unnest(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) with ordinality

-- round 函数用于把数值字段舍入为指定的小数位数
-- 注：使用 round 函数时注意统一字段类型，可使用 as 或者 &#39;::&#39; 转换字段类型
select round(12.743874,2)

-- random() 函数可以获取随机数，固定公式 random() * (num1 - num2)+num2
select random() * (100-1) + 1 --获取 1 ~ 100 以内的随机数

-- generate_series() 函数可以按不同的规则产生一系列的填充数据
-- generate_series(start, stop) 获取100个 1 ~ 100 以内的随机数
select (random() * (100-1) + 1) as num from generate_series(1,100)
-- generate_series(start, stop, step) 生成一个数值序列，从start 到 stop，步进为step
select generate_series(10,1,-1)
-- generate_series(start, stop, step_interval) 生成一个数值序列，从start 到 stop，步进为step
select generate_series(now(), now() + &#39;7 days&#39;, &#39;1 day&#39;)

-- 创建序列
create sequence seq_user increment by 1 minvalue 1 no maxvalue start with 1

-- nextval() 函数递增序列并返回新值
select nextval(seq_user)
</code></pre>

    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2020 - 2022 Harvch( ‘-ωก̀ )です
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @Harvch
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
		<canvas id="background" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:-1" ></canvas>
		<canvas id="fireworks" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:2147483647" ></canvas> 
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
		<script src="/js/fireworks.js"></script>
		<script src="/js/background.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>