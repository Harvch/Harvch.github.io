{"meta":{"title":"Harvch( ‘-ωก̀ )です","subtitle":"","description":"","author":"Harvch","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-07-11T09:04:26.000Z","updated":"2022-07-11T09:06:00.523Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-11T09:06:35.000Z","updated":"2022-07-11T09:07:17.660Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"开发常见问题","slug":"开发常见问题","date":"2022-07-12T07:45:52.000Z","updated":"2022-07-12T09:28:44.362Z","comments":true,"path":"2022/07/12/开发常见问题/","link":"","permalink":"http://example.com/2022/07/12/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"我们在做开发的时候经常会遇见各种各样的问题，分享一下我遇到的一些问题以及解决办法","text":"我们在做开发的时候经常会遇见各种各样的问题，分享一下我遇到的一些问题以及解决办法 windows 系统启动服务时出现报错 1.Windows启动服务出现错误“并非所有的功能被成功更改” 的问题 按 “Windows 徽标键+X”，启动 “Windows PowerShell（管理员）”，输入以下命令： Dism /Online /Cleanup-Image /ScanHealth 这条命令将扫描全部系统文件并和官方系统文件对比，扫描计算机中的不一致情况 Dism /Online /Cleanup-Image /CheckHealth 这条命令必须在前一条命令执行完以后，发现系统文件有损坏时使用 DISM /Online /Cleanup-image /RestoreHealth 这条命令是把那些不同的系统文件还原成官方系统源文件 无论前三条命令是否可用，完成后重启，再键入以下命令： sfc /SCANNOW maven 常见问题有的时候需要将一些自己封装的包放入本地仓库进行程序打包，可以是由 mvn 指令将包放入本地仓库 //将本地文件放入本地仓库，仓库的位置跟你本地的 settings.xml 配置有关 mvn install:install-file -Dfile=D:\\company\\encrypt_sdk.jar -DgroupId=encrypt_sdk -DartifactId=encrypt_sdk -Dversion=1.0 -Dpackaging=jar idea maven 插件打包报错不知道怎么解决，可以尝试将依赖从本地仓库移除重新下载，或者使用 mvn 打包指令 //mvn 打包进入调试模式，会有比较详细的报错信息，应该能帮助你找到问题 mvn package -x 前端传参常见问题 参数格式化（数组），前端请求后端 api 带数组参数比较特殊不做处理可能导致后端无法正常接收到参数 //vue axios请求 paramsSerializer: params =&gt; &#123; return qs.stringify(params, &#123; indices: false &#125;) &#125; //ajax 请求 添加traditional 请求参数为 true, 也可以将参数转换为 json 再传递 $.ajax(&#123; url: &#39;apiurl&#39;, data: data[], type: &#39;post&#39;, traditional:true， success: res =&gt; &#123; //代码省略... &#125;, error: err =&gt; &#123; //代码省略... &#125; &#125;) Cookie 当浏览器存在 cookie 时向 api 发送请求会自动将 cookie 带入请求（统一域名） 注：特定情况下会自动将cookie带入请求头部 依赖排除 ​ 例：由于 log4j 2.17 版本以下出现高危漏洞，springboot-stater 依赖整合了 log4j 依赖如果直接去除会导致项目无法运行，建议更换 2.17.1 版本 &lt;!-- 2.17.0修复漏洞版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.17.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.17.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.17.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; npm 清理缓存 web前端可能由于网络波动造成下载超时，npm缓存未清理造成依赖下载失败，解决（清理 npm 缓存） npm cache clean --force 查看 npm 缓存的位置 npm cache dir 可能由于版本问题无法执行上一条指令，可以尝试下面这条 npm config list --json","categories":[],"tags":[{"name":"常见问题","slug":"常见问题","permalink":"http://example.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}]},{"title":"Postgresql数据库","slug":"Postgresql数据库","date":"2022-07-11T11:23:05.000Z","updated":"2022-07-11T12:06:56.049Z","comments":true,"path":"2022/07/11/Postgresql数据库/","link":"","permalink":"http://example.com/2022/07/11/Postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"Postgresql数据库是关系型数据库 下载地址： https://www.enterprisedb.com/downloads/postgres-postgresql-downloads","text":"Postgresql数据库是关系型数据库 下载地址： https://www.enterprisedb.com/downloads/postgres-postgresql-downloads WITH 查询 ​ WITH查询是PostgreSQL支持的高级SQL特性之一，这一特性常称为CTE(Common Table Expressions)，WITH查询在复杂查询中定义一个辅助语句（可理解成在一个查询中定义的临时表），这一特性常用于复杂查询或递归查询应用场景 with a as (select * from wp_dkbasedatainfo where xzqdm =&#39;650203&#39; ) select * from a ,b where a.tbflqk=&#39;实地伪变化&#39; ​ WITH 查询的一个重要属性是 RECURSIVE，使用 RECURSIVE 属性可以引用自己的输出，从而实现递归，一般用于层次结构或树状结构的应用场景 例如，存在一张包含如下数据的表： id name fatherid1 中国 02 辽宁 13 山东 14 沈阳 25 大连 26 济南 37 和平区 48 沈河区 4 使用PostgreSQL的WITH查询检索ID为7以及以上的所有父节点，如下： WITH RECURSIVE r AS ( SELECT * FROM test_area WHERE id = 7 UNION ALL SELECT test_area.* FROM test_area, r WHERE test_area.id = r.fatherid ) SELECT * FROM r ORDER BY id; 查询结果如下： id | name | fatherid----+--------+---------- 1 | 中国 | 0 2 | 辽宁 | 1 4 | 沈阳 | 2 7 | 和平区 | 4(4 rows) WITH RECURSIVE WITH 语句还可以通过增加 RECURSIVE 修饰符来引入它自己，从而实现递归 WITH RECURSIVE 一般用于处理逻辑上层次化或树状结构的数据，典型的使用场景是寻找直接及间接子结点 定义下面这样的表，存储每个区域（省、市、区）的 id，名字及上级区域的 id CREATE TABLE chinamap ( id INTEGER, pid INTEGER, name TEXT ); 需要查出某个省，比如湖北省，管辖的所有市及市辖地区，可以通过WITH RECURSIVE来实现，如下： WITH RECURSIVE result AS ( SELECCT id, name FROM chinamap WHERE id = 11 UNION ALL SELECT origin.id, result.name || &#39; &gt; &#39; || origin.name FROM result JOIN chinamap origin ON origin.pid = result.id ) SELECT id, name FROM result; 结果如下： id | name -----+-------------------------- 11 | 湖北省 110 | 湖北省 &gt; 武汉市 120 | 湖北省 &gt; 孝感市 130 | 湖北省 &gt; 宜昌市 140 | 湖北省 &gt; 随州市 150 | 湖北省 &gt; 仙桃市 160 | 湖北省 &gt; 荆门市 170 | 湖北省 &gt; 枝江市 180 | 湖北省 &gt; 神农架市 111 | 湖北省 &gt; 武汉市 &gt; 武昌区 112 | 湖北省 &gt; 武汉市 &gt; 下城区 113 | 湖北省 &gt; 武汉市 &gt; 江岸区 114 | 湖北省 &gt; 武汉市 &gt; 江汉区 115 | 湖北省 &gt; 武汉市 &gt; 汉阳区 116 | 湖北省 &gt; 武汉市 &gt; 洪山区 117 | 湖北省 &gt; 武汉市 &gt; 青山区 (16 rows) WITH RECURSIVE 执行过程 从上面的例子可以看出，WITH RECURSIVE语句包含了两个部分 non-recursive term（非递归部分），即上例中的union all前面部分 recursive term（递归部分），即上例中union all后面部分 执行步骤如下： 执行non-recursive term（如果使用的是union而非union all，则需对结果去重）其结果作为recursive term中对result的引用，同时将这部分结果放入临时的working table中 重复执行如下步骤，直到working table为空：用working table的内容替换递归的自引用，执行recursive term，（如果使用union而非union all，去除重复数据），并用该结果（如果使用union而非union all，则是去重后的结果）替换working table 以上面的query为例，来看看具体过程： 1.执行： SELECT id, nameFROM chinamapWHERE id = 11 结果集和 working table 为： 11 | 湖北 2.执行： SELECT origin.id, result.name || &#39; &gt; &#39; || origin.name FROM result JOIN chinamap origin ON origin.pid = result.id 结果集和 working table 为： 110 | 湖北省 &gt; 武汉市 120 | 湖北省 &gt; 孝感市 130 | 湖北省 &gt; 宜昌市 140 | 湖北省 &gt; 随州市 150 | 湖北省 &gt; 仙桃市 160 | 湖北省 &gt; 荆门市 170 | 湖北省 &gt; 枝江市 180 | 湖北省 &gt; 神农架市 3.再次执行recursive query，结果集和working table为： 111 | 湖北省 &gt; 武汉市 &gt; 武昌区 112 | 湖北省 &gt; 武汉市 &gt; 下城区 113 | 湖北省 &gt; 武汉市 &gt; 江岸区 114 | 湖北省 &gt; 武汉市 &gt; 江汉区 115 | 湖北省 &gt; 武汉市 &gt; 汉阳区 116 | 湖北省 &gt; 武汉市 &gt; 洪山区 117 | 湖北省 &gt; 武汉市 &gt; 青山区 4.继续执行recursive query，结果集和working table为空 5.结束递归，将前三个步骤的结果集合并，即得到最终的WITH RECURSIVE的结果集严格来讲，这个过程实现上是一个迭代的过程而非递归，不过RECURSIVE这个关键词是SQL标准委员会定立的，所以PostgreSQL也延用了RECURSIVE这一关键词 WITH RECURSIVE 防止死循环 ​ 从上一节中可以看到，决定是否继续迭代的working table是否为空，如果它永不为空，则该CTE将陷入无限循环中 对于本身并不会形成循环引用的数据集，无段作特别处理而对于本身可能形成循环引用的数据集，则须通过SQL处理 ​ 一种方式是使用UNION而非UNION ALL，从而每次recursive term的计算结果都会将已经存在的数据清除后再存入working table，使得working table最终会为空，从而结束迭代 ​ 然而，这种方法并不总是有效的，因为有时可能需要这些重复数据同时UNION只能去除那些所有字段都完全一样的记录，而很有可能特定字段集相同的记录即应该被删除此时可以通过数组（单字段）或者ROW（多字段）记录已经访问过的记录，从而实现去重的目的 WITH RECURSIVE 求最短路径 定义如下表并存入每条边的权重 CREATE TABLE graph ( id char, neighbor char, value integer ); INSERT INTO graph VALUES(&#39;A&#39;, &#39;B&#39;, 3), (&#39;A&#39;, &#39;C&#39;, 5), (&#39;A&#39;, &#39;D&#39;, 4), (&#39;B&#39;, &#39;E&#39;, 8), (&#39;B&#39;, &#39;C&#39;, 4), (&#39;E&#39;, &#39;C&#39;, 7), (&#39;E&#39;,&#39;F&#39;, 10), (&#39;C&#39;, &#39;D&#39;, 3), (&#39;C&#39;, &#39;F&#39;, 6), (&#39;F&#39;,&#39;D&#39;, 5); 计算思路如下： 因为是无向图，所以首先要将各条边的id和neighbor交换一次以方便后续计算 利用WITH RECURSIVE算出所有可能的路径并计算其总权重 因为该图有环，为避免无限循环，同时为了计算路径，将经过的结点存于数据中，当下一个结点已经在数据中时，说明该结点已被计算 最终可算出所有可能的路径及其总权重 实现如下： WITH RECURSIVE edges AS ( SELECT id, neighbor, value FROM graph UNION ALL SELECT neighbor, id, value FROM graph ), all_path (id, neighbor, value, path, depth, cycle) AS ( SELECT id, neighbor, value, ARRAY[id], 1, &#39;f&#39;::BOOLEAN FROM edges WHERE id = &#39;A&#39; UNION ALL SELECT all_path.id, edges.neighbor, edges.value + all_path.value, all_path.path || ARRAY[edges.id], depth + 1, edges.id = ANY(all_path.path) FROM edges JOIN all_path ON all_path.neighbor = edges.id AND NOT cycle ), a_f AS ( SELECT rank() over(order by value) AS rank, path || neighbor AS path, value, depth FROM all_path WHERE neighbor = &#39;F&#39; ) SELECT path, value, depth FROM a_f WHERE rank = 1; WITH RECURSIVE 使用限制 如果在recursive term中使用LEFT JOIN，自引用必须在“左”边 如果在recursive term中使用RIGHT JOIN，自引用必须在“右”边 recursive term中不允许使用FULL JOIN recursive term中不允许使用GROUP BY和HAVING 不允许在recursive term的WHERE语句的子查询中使用CTE的名字 不支持在recursive term中对CTE作aggregation recursive term中不允许使用ORDER BY LIMIT &#x2F; OFFSET不允许在recursive term中使用 FOR UPDATE不可在recursive term中使用 recursive term中SELECT后面不允许出现引用CTE名字的子查询 同时使用多个CTE表达式时，不允许多表达式之间互相访问（支持单向访问） 在recursive term中不允许使用FOR UPDATE CTE 优缺点 可以使用递归 WITH RECURSIVE，从而实现其它方式无法实现或者不容易实现的查询 当不需要将查询结果被其它独立查询共享时，它比视图更灵活也更轻量 CTE只会被计算一次，且可在主查询中多次使用 CTE可极大提高代码可读性及可维护性 CTE不支持将主查询中where后的限制条件push down到CTE中，而普通的子查询支持 2.数据库中的数据如果不存在则插入，存在则更新 INSERT INTO test_postgre(id,name,InputTime,age) VALUES(&#39;1&#39;,&#39;postgre&#39;,&#39;2018-01-10 22:00:00&#39;,24) ON conflict(id) DO UPDATE SET name = &#39;postgreOk&#39;, InputTime =&#39;2018-02-22 12:00:00&#39; 常用 SQL 语句 -- 如果表中存在了 id 这条数据则更新否则向表中插入数据 INSERT INTO test_postgre(id,name,InputTime,age) VALUES(&#39;1&#39;,&#39;postgre&#39;,&#39;2018-01-10 22:00:00&#39;,24) ON conflict(id) DO UPDATE SET name = &#39;postgreOk&#39;, InputTime =&#39;2018-02-22 12:00:00&#39; -- 如果 a.title 为空则取 b.title 的值 select coalesce(a.title,b.title) from a join b on a.pid = a.id -- 筛选 title 列为空的数据 select * from a where a.title is null -- 筛选 title 列为非空的数据 select * from a where a.title is not null -- case when 语句块的使用 select ( case when fwxz = &#39;0&#39; then &#39;市场化商品房&#39; when fwxz = &#39;1&#39; then &#39;动迁房&#39; when fwxz = &#39;2&#39; then &#39;配套商品房&#39; when fwxz = &#39;3&#39; then &#39;公共租赁住房&#39; when fwxz = &#39;4&#39; then &#39;廉租住房&#39; when fwxz = &#39;5&#39; then &#39;限价普通商品住房&#39; when fwxz = &#39;6&#39; then &#39;经济适用住房&#39; when fwxz = &#39;7&#39; then &#39;定销商品房&#39; when fwxz = &#39;8&#39; then &#39;集资建房&#39; when fwxz = &#39;9&#39; then &#39;福利房&#39; when fwxz = &#39;10&#39; then &#39;保障性住房&#39; when fwxz = &#39;11&#39; then &#39;房改房&#39; when fwxz = &#39;12&#39; then &#39;自建房&#39; when fwxz = &#39;99&#39; then &#39;其它&#39; else fwxz end ) as fwxz,count(*) from fwb_qjcg_hb group by fwxz -- 查询时去除重复的数据 select distinct name,phone from user -- 更新返回更新后列的数据 update &quot;user&quot; set username = &#39;aa&#39; returning username -- 插入表中某列的数据返回插入后的数据 insert into &quot;user&quot;(username) values(&#39;张三&#39;) returning username -- unnest 函数将输入的数组转换成一个表,这个表的每一列都代表相应的一个数组中的元素 select &#39;张三&#39; as name ,unnest(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) as course -- with ordinality 用于给返回的结果集增加一个整数列，这个整数列从1开始，并且按1递增 -- 注： with ordinality 必须使用在from子句中，且要紧跟在函数后面使用！ select * from unnest(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) with ordinality -- round 函数用于把数值字段舍入为指定的小数位数 -- 注：使用 round 函数时注意统一字段类型，可使用 as 或者 &#39;::&#39; 转换字段类型 select round(12.743874,2) -- random() 函数可以获取随机数，固定公式 random() * (num1 - num2)+num2 select random() * (100-1) + 1 --获取 1 ~ 100 以内的随机数 -- generate_series() 函数可以按不同的规则产生一系列的填充数据 -- generate_series(start, stop) 获取100个 1 ~ 100 以内的随机数 select (random() * (100-1) + 1) as num from generate_series(1,100) -- generate_series(start, stop, step) 生成一个数值序列，从start 到 stop，步进为step select generate_series(10,1,-1) -- generate_series(start, stop, step_interval) 生成一个数值序列，从start 到 stop，步进为step select generate_series(now(), now() + &#39;7 days&#39;, &#39;1 day&#39;) -- 创建序列 create sequence seq_user increment by 1 minvalue 1 no maxvalue start with 1 -- nextval() 函数递增序列并返回新值 select nextval(seq_user)","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://example.com/tags/sql/"}]},{"title":"","slug":"Hello World","date":"2022-07-08T09:34:22.648Z","updated":"2022-07-11T11:34:38.896Z","comments":true,"path":"2022/07/08/Hello World/","link":"","permalink":"http://example.com/2022/07/08/Hello%20World/","excerpt":"","text":"Hello World纪念一下 我的 blog 诞生","categories":[],"tags":[]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"常见问题","slug":"常见问题","permalink":"http://example.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"sql","slug":"sql","permalink":"http://example.com/tags/sql/"}]}