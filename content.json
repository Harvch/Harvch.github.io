{"meta":{"title":"Harvch( ‘-ωก̀ )です","subtitle":"","description":"","author":"Harvch","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-07-11T09:04:26.000Z","updated":"2022-07-11T09:06:00.523Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-11T09:06:35.000Z","updated":"2022-07-11T09:07:17.660Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot框架","slug":"SpringBoot框架","date":"2022-08-12T01:25:47.000Z","updated":"2022-08-12T07:14:56.220Z","comments":true,"path":"2022/08/12/SpringBoot框架/","link":"","permalink":"http://example.com/2022/08/12/SpringBoot%E6%A1%86%E6%9E%B6/","excerpt":"SpringBoot 框架","text":"SpringBoot 框架 一、SpringBoot 概述 1. SpringBoot 介绍 SpringBoot 是 Spring 家族中的一个框架，它是用来简化 Spring 应用程序的创建和开发；SpringBoot 完全抛弃了繁琐的 XML 配置。使用 SpringBoot 可以非常容易的创建基于 Spring 框架的应用程序 2. SpringBoot 特性 1、能快速的创建基于 spring 的应用程序 2、能直接使用 main 方法，启用内嵌的 Tomcat 服务器，可以直接运行 SpringBoot 应用程序 3、提供了约定的 startter POM 来简化 Maven 配置 4、自动化配置 5、基本可以完全不使用xml配置文件，采用注解进行配置 3. SpringBoot 优缺点 1、优点 构建项目速度快 对主流的开发框架集成 项目可以独立运行，无需外部的 servlet 容器 2、缺点 版本迭代快 封装太深，内部原理复杂 二、SpringBoot项目创建 1.手动创建项目 手动创建 Maven 项目（不要使用模板） pom 文件的配置（引入相应的依赖） SpringBoot 项目都有一个父工程依赖 &lt;!--引入 SpringBoot 的父工程依赖--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;version&gt;2.4.5&lt;/version&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;/parent&gt; &lt;!--引入依赖 web--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 创建 SpringBoot 项目的启动类，启动类要使用 @SpringBootApplication 注解进行标识 @SpringBootApplication public class SpringBootMain&#123; public static void main(String[] args) &#123; //启动应用程序 SpringApplication.run(SpringBootMain.class,args); &#125; &#125; @Controller public class HelloController &#123; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; return &quot;Hello SpringBoot&quot;; &#125; &#125; 三、依赖管理 1. SpringBoot 项目是由父工程进行依赖管理 每个 SpringBoot 项目都有一个父工程 //是Spring-boot-starter-parent &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; //是spring-boot-starter-parent的pom文件 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;/parent&gt; 父工程管理应用程序中可能用到的依赖的版本 修改依赖的版本： 直接在依赖中添加标识 在中进行版本约束，此时版本约束的标识必须与 “spring-boot-dependencies” 中规定的版本标识一致 2. 场景启动器 在 SpringBoot 项目中有 “ spring-boot-starter-“ 场景（：某种场景），只要引入了场景，此场景下的依赖都引入到项目中 所有的场景都依赖 “spring-boot-starter” 3. 自动装配 @SpringBootApplication 注解 作用：标识此项目是一个 SpringBoot 项目 组成：由 @SpringBootConfiguration、@EnableAutoConfiguration、@ConponentScan @SpringBootConfiguration 注解： 标识一个类是配置类，相当于 @Configuration 注解，可以被 ComponentScan 扫描到 @EnableAutoConfiguration 注解： 开启自动配置 组成：@AutoConfigurationPackage、@Import @AutoConfigurationPackage 组件扫描的位置 @Import 加载可以用到的配置类 @ComponentScan 注解 组件扫描 4. 默认包结构 SpringBoot 自动扫描主程序所在的包及其子包下的所有组件 更改包扫描的位置 修改 @SpringBootApplication 注解的 scanBasePackages 属性 @SpringBootApplication(scanBasePackages = &quot;com.jbit&quot;) 四、容器功能 @Configuration 注解 作用：标识类是一个配置类（配置类相当于是 spring 的配置文件） @Bean 注解 作用：将组件注册到 SpringBoot 容器中 注意：此注解使用在方法上 @Configuration //标识此类是⼀个配置类，相当于配置⽂件;配置类也是springboot 中的⼀个组件 public class EntityConfig &#123; /* @Bean注解： 将组件注册到容器中,是使⽤在⽅法上的 ⽅法名就是组件的id，相当于配置⽂件中的id属性 ⽅法返回类型就是组件的实体 */ @Bean(name=&quot;zhang&quot;) //name -&gt; 组件在容器当中的名称 public Users getUser() &#123; return new Users(&quot;张三&quot;,20) &#125; &#125; 注意：配置类也是 SpringBoot 中的一个组件 SpringBoot 中的组件都是单列 2. @Configuration 注解的属性 proxyBeanMethods 属性 作用： 是否使用代理的方式获取组件 取值： true &gt; 每次获取组件时都要检查容器中是否有相应的组件，获取组件是从容器中获取的；默认值 false &gt; 每次获取组件时不会检查容器中是否有相应的组件，通过调用方法的形式获取组件 目的： 保证容器中的组件是单例模式 使用场景： 主要使用在有组件依赖的时候 3. 条件装配 说明： 当满足某个条件时，才将组件注入到容器中 @Conditional 注解 &gt; 条件装配注解的父类 ​ 使用 ctrl+n 搜索 @Conditional 注解，打开源码，使用 ctrl+h 显示 @Conditional 的子类 @Bean(name = &quot;zhang&quot;) //name是springboot容器中组件的名称 @ConditionalOnBean(name = &quot;dog&quot;) public Users getUser() &#123; Users user = new Users(&quot;zhangsan&quot;, 20); user.setPet(getPet()); return user; &#125; // @Bean(name = &quot;dog&quot;) public Pet getPet() &#123; return new Pet(&quot;拉布拉多&quot;); &#125; 注意： 使用在方法上，表示满足条件后装配指定的组件 使用在配置类上，表示满足条件后装配配置类中的所有组件 4. 原生配置文件的引入 @ImportResource 注解 作用： 引入原生的配置文件 位置： 使用在任意的配置类中 语法： @ImportResource({“原生配置文件的路径”}) @Configuration //引入原生的配置文件 @ImportResource(&#123;&quot;classpath:springbean.xml&quot;&#125;) public class ImportResourceConfig &#123; &#125; 5. 属性绑定 可以在 SpringBoot 的配置文件中设置属性值进行属性绑定 使用 @ConfigurationProperties 注解进行属性绑定 作用： 属性绑定 位置： 实体类上 要求： 使用此注解的类必须是容器中的组件（要使用 @Component） #配置 Student 对象的属性值 stu: stuName:jack gradeName:Y2 //表示是容器的组件 @Component //绑定属性 @ConfigurationProperties(prefix = &quot;stu&quot;) public class Student &#123; private String stuName; private String gradeName; &#125; 采用 @Value 注解进行属性绑定 作用： 给实体类中的属性绑定值 位置： 属性的上面 语法： @Value(“${前缀.属性名}”) teacher: teacherName:tom gradeName:Y2 @Component public class Teacher &#123; @Value(&quot;$&#123;teacher.teacherName&#125;&quot;) private String teacherName; @Value(&quot;$&#123;teacher.gradeName&#125;&quot;) private String gradeName; @EnableConfigurationProperties + @ConfigurationProperties 实现属性绑定 @EnableConfigurationProperties 作用： 开启组件属性配置功能（让 @ConfigurationProperties 注解生效） 将组件自动的注册到容器中 @ConfigurationProperties(prefix = &quot;car&quot;) public class Car &#123; private String brand; private int price; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;brand=&#39;&quot; + brand + &#39;\\&#39;&#39; + &quot;, price=&quot; + price + &#39;&#125;&#39;; &#125; //配置类 @Configuration @EnableConfigurationProperties(Car.class) public class propertiesConfig &#123; &#125; //配置文件（yml文件） car: brand:丰田 price:1 //使用（在controller为例） @Autowired//自动注入组件 private Car car; @RequestMapping(&quot;car&quot;) @ResponseBody public Car getCar() &#123; return car &#125; 6. 热部署（热更新） 当 SpringBoot 中的内容发生改变，可以使用 ctrl+F9 引入 devtools 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;true&lt;/scope&gt; &lt;/dependency&gt; 五、配置文件 SpringBoot 的核心配置文件用于配置 SpringBoot 程序，名字必须以 application 开头 1. .properties文件 是 SpringBoot 采用的默认的配置文件 #配置tomcat信息 #配置端口 server.port=8888 #配置上下文路径，上下文路径必须是&quot;/&quot;开头 server.servlet.context-path==/spring 2. .yaml 文件（也是 .yml 文件） 采用一定的空格、换行等格式排版进行配置， YAML 是”YAML Ain’t Markup Language” （YAML不是一种标记语言）、在开发中YAML（Yet Mnother Markup Language）仍是一种标记语言 适用于以数据为中心的配置文件 语法： ​ key:value 说明： ​ key 之间必须有空格 ​ 大小写敏感 ​ 以缩进形式标识层级关系 ​ 缩进不能使用 tab，必须使用空格，空格的个数没有要求，同级的元素左对齐 #配置端口号 server: port: 9090 #配置上下文 servlet: context-path: /boot 3. 多环境的配置 根据不同的要求（开发、测试、上线），有不同的配置文件 要求：每一个环境创建的配置文件命名格式：application-环境标识 properties | yml #开发环境的配置（application-dev.yml） #配置端口和上下文路径 server: port: 8089 servlet: context-path: /dev #测试环境配置文件（application-test.yml） #配置端口和上下文路径 server: port: 9191 servlet: context-path: /test #生产环境配置（application-product.yml） #配置端口和上下文路径 server: port: 6060 servlet: context-path: /product #application.yml -&gt; 主配置文件 -&gt; 让指定的配置文件生效 spring: profiles: active: test 六、SpringBoot Web开发 SpringBoot 自动配置了 SpringMVC 1. 静态资源的访问 ​ 静态资源的目录： ​ &#x2F;static、&#x2F;public、&#x2F;resources、&#x2F;META-INF&#x2F;resources ​ 可以通过项目路径&#x2F;+静态资源形式访问项目中的静态资源 ​ http://localhost:8080/9.jpg ​ 问题： ​ 静态资源的访问路径与Controller的访问路径重名，将不能访问静态资源 ​ 原因： ​ 静态资源的映射路径是 “&#x2F;**” ，由于 spring 中的核心控制器（DispatcherServlet）拦截的是所有请求的时候都会进入Controller 进 行处理，Controller 如果能处理请求直接处理用户的去请求，不能处理时交给静态资源处理，静态资源都不能处理返回404 ​ 解决： ​ 可以通过配置静态资源的前缀（spring.mvc.static-path-pattern） #配置静态资源的前缀 spring.mvc.static-path-pattern=/res/** ​ 访问静态资源的路径格式：项目根路径&#x2F;+静态资源前缀&#x2F;+静态资源名 2. 修改静态资源路径 #配置静态资源路径 spring.resources.static-locations=classpath:/abc/ 只有静态资源放置在修改后的目录才能（META-INF&#x2F;resources目录除外）中才能访问 3. 欢迎页面 欢迎页面就是直接访问项目的根路径显示的页面 在 SpringBoot 中使用静态资源路径下的 index.html 作为欢迎页面 注意：如果要使用欢迎页面，静态资源不能配置前缀；否者欢迎页面无效 4. Rest 风格 为什么需要 Rest 风格 ​ 以前是通过 URL 表示功能的操作（通过 URL 以 Controller 中的方法进行匹配）；需要对模块的操作的 URL 相同，处理请求的方 法与提交请求的方式进行匹配 什么是 Rest 风格 ​ 使用 HTTP 请求方式的动词来表示请求资源的操作 ​ Get请求（获取数据）、Post请求（添加数据），Put请求（更新数据），Delete请求（删除数据） 使用Rest风格 ​ 注意： ​ 表单只能提交get和post请求，即使表单中的method属性取值为Put、Delete都是调用的get请求 ​ 配置Rest风格： ​ Rest风格的核心 - Filter（HiddeenHttpMethodFilter） ​ 在SpringBoot中已经自动配置HiddenHttpMethodFilter ​ 注意： ​ 1. 在springboot中HiddenHttpMethodFilter过滤器是默认关闭的 #开启Rest风格 spring.mvc.hiddenmethod.filter.enabled=true ​ 2. 使用Rest风格表单的提交方式必须是post方式（get请求除外） ​ 3. 使用Rest风格表单提交时必须提交一个参数：_method，参数的取值为：（put、delete、patch） &lt;body&gt; &lt;h1&gt;测试Rest风格&lt;/h1&gt; &lt;form action=&quot;/user&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Rest-Get请求&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Rest-Post请求&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Rest-Put请求&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Rest-Delete请求&quot;&gt; &lt;/form&gt; &lt;/body&gt; @RestController public class RestsController &#123; /* 1、保存用户 2、删除用户 3、获取用户 */ @GetMapping(&quot;/user&quot;) //@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET) public String getUser() &#123; return &quot;GET-张三&quot;; &#125; @PostMapping(&quot;/user&quot;) //@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST) public String saveUser() &#123; return &quot;POST-张三&quot;; &#125; @PutMapping(&quot;/user&quot;) //@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT) public String editUser() &#123; return &quot;PUT-张三&quot;; &#125; //@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE) @DeleteMapping(&quot;/user&quot;) public String deleteUser() &#123; return &quot;DELETE-张三&quot;; &#125; &#125; 七、Thymeleaf模板 1. Thymeleaf介绍 ​ Thymeleaf是使用在Web和独立环境的服务器端Java模板引擎 ​ 能够处理HTML\\XML\\JavaScript\\CSS及纯文本文件 ​ 可以作为MVC Web应用中View层展示数据 ​ SpringBoot是内嵌的容器，建议打包成Jar，不推荐使用JSP，使用Thymeleaf进行数据渲染 2. Thymeleaf基本语法 在HTML引入Thymeleaf约束 ​ 在标签中添加约束 “ xmlns&#x3D;’http://www.thymeleaf.org&#39; “ &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymelef.org&quot;&gt; 示例： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymelef.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;测试Thymeleaf&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- th -&gt; thymeleaf表达式的前缀 th:text -&gt; 修改HTML元素文本值 --&gt; &lt;h1 th:text=&quot;hello&quot;&gt;你好&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; ​ 说明： ​ Thymeleaf的页面可以独立运行，Thymeleaf表达式不起作用，显示的就是HTML中的原始内容 ​ Thymeleaf的页面是通过后端跳转的，渲染后端的数据 表达式 ​ 变量取值：${….} -》获取变量或作用域中的数据 ​ 链接：@{…..} -》生成链接 ​ 选择变量：*{….} -》获取变量的值 ​ 消息：#{….} -》 获取国际化等值 ​ 片段表达式： ~{….} -》 引入页面判断 字面值 ​ 文本值、数字值、布尔值、空值、变量 文本操作 ​ 文本的连接 ​ a). ‘+’ &lt;span th:text=&quot;&#39;图书的名称是:&#39;+$&#123;session.book.title&#125;&quot;&gt;&lt;/span&gt; ​ b). ‘||’ &lt;span th:text=&quot;|图书的名称是:$&#123;session.book.title&#125;|&quot;&gt;&lt;/span&gt; 算术运算符 ​ +、-、*、&#x2F;、% 比较运算符 ​ 大于：gt、小于：lt、大于等于：ge、小于等于：le、等于：eq、不等于：ne 布尔运算 ​ 与：and、或：or、非：not 条件判断 ​ th:if &gt; 条件成立（条件成立显示类容） ​ th:unless &gt; 条件不成立（条件不成立显示类容） &lt;h1&gt; 图书：[[$&#123;session.book.title&#125;]]的价格为：￥[[$&#123;session.book.price&#125;]] &lt;span th:if=&quot;$&#123;session.book.price&#125; &gt; 20&quot;&gt;好贵&lt;/span&gt; &lt;span th:unless=&quot;$&#123;session.book.price&#125; &lt; 20&quot;&gt;好贵&lt;/span&gt; &lt;/h1&gt; 分支语句 ​ th:switch 和 th:case &lt;body&gt; &lt;h1&gt;测试分支结构&lt;/h1&gt; &lt;div th:switch=&quot;$&#123;result&#125;&quot;&gt; &lt;h1 th:case=&quot;90&quot;&gt;优秀&lt;/h1&gt; &lt;h1 th:case=&quot;80&quot;&gt;良好&lt;/h1&gt; &lt;h1 th:case=&quot;70&quot;&gt;及格&lt;/h1&gt; &lt;h1 th:case=&quot;*&quot;&gt;不及格&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; 迭代语句 ​ th:each&#x3D;”变量[,变量状态]” : “集合&#x2F;数组” &lt;body&gt; &lt;!-- str -&gt; 迭代语句的中间变量 strStart -&gt; 迭代语句中的状态变量 --&gt; &lt;h1&gt;测试迭代语句&lt;/h1&gt; &lt;ul th:each=&quot;str,strStart : $&#123;lists&#125;&quot;&gt; &lt;li th:text=&quot;$&#123;str&#125;&quot;&gt;&lt;/li&gt; &lt;ul&gt; &lt;li th:text=&quot;|索引(index),从0开始:$&#123;strStart.index&#125;|&quot;&gt;&lt;/li&gt; &lt;li th:text=&quot;|元素个数(count),$&#123;strStart.count&#125;|&quot;&gt;&lt;/li&gt; &lt;li th:text=&quot;|元素总个数(size),$&#123;strStart.size&#125;|&quot;&gt;&lt;/li&gt; &lt;li th:text=&quot;|当前遍历的元素(current),$&#123;strStart.current&#125;|&quot;&gt;&lt;/li&gt; &lt;li th:text=&quot;|是否是偶数(odd),$&#123;strStart.odd&#125;|&quot;&gt;&lt;/li&gt; &lt;li th:text=&quot;|是否是奇数(even),$&#123;strStart.even&#125;|&quot;&gt;&lt;/li&gt; &lt;li th:text=&quot;|是否是第一个数据(first),$&#123;strStart.first&#125;|&quot;&gt;&lt;/li&gt; &lt;li th:text=&quot;|是否是最后一个数据(last),$&#123;strStart.last&#125;|&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/ul&gt; &lt;/body&gt; 自定义变量 ​ th:with&#x3D;”变量名&#x3D;表达式” ​ 使用变量：使用变量表达式${…}获取变量中的数据 ​ th:object&#x3D;”表达式” ​ 将对象的信息进行保存，可以通过选择变量表达式*{……}获取对象的属性值 &lt;h1&gt;自定义变量&lt;/h1&gt; &lt;div th:with=&quot;stuName=&#39;张三&#39;&quot;&gt; &lt;h1 th:text=&quot;|学员的姓名是:$&#123;stuName&#125;|&quot;&gt;&lt;/h1&gt; &lt;/div&gt; &lt;h1&gt;保存对象信息&lt;/h1&gt; &lt;div th:object=&quot;$&#123;book&#125;&quot;&gt; &lt;h1 th:text=&quot;|图书的名称是:*&#123;title&#125;|&quot;&gt;&lt;/h1&gt; &lt;h1 th:text=&quot;|图书的价格是:*&#123;price&#125;|&quot;&gt;&lt;/h1&gt; &lt;/div&gt; 内置对象 ​ #dates：日期内置对象 ​ #numbers：数字 ​ #strings：字符串 ​ #object：Object ​ #bools：Boolean ​ #arrays：数组 ​ #lists：集合 ​ #sets：set集合 ​ #maps：map集合 ​ #messages：消息工具 3. SpringBoot整合Thymeleaf ​ 1. 引入Thymeleaf的依赖 &lt;!--Thymeleaf依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; ​ 2. SpringBoot自动配置了Thymeleaf @Configuration @EnableConfigurationProperties(&#123;ThymeleafProperties.class&#125;) @ConditionalOnClass(&#123;TemplateMode.class&#125;) @AutoConfigureAfter(&#123;WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class&#125;) public class ThymeleafAutoConfiguration &#123; &#125; ​ ThymeleafProperties类中 @ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;) public class ThymeleafProperties &#123; private static final java.nio.charset.Charset DEFAULT_ENCODING; public static final java.lang.String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final java.lang.String DEFAULT_SUFFIX = &quot;.html&quot;; &#125; ​ 自动配置了视图解析器：thymeleafViewResolver ​ 注意： ​ 1. Thymeleaf展示数据的文件的位置：”&#x2F;templates” ​ 2. Thymeleaf默认的 文件类型是：”.html” ​ 3. Thymeleaf页面跳转都是通过Controller进行控制的 八、SpringBoot整合JSP 1. 引入JSP依赖 &lt;!--引入JSP依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jasper是Tomcat使用JSP引擎，可以将项目与Tomcat分离 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; 2. 更新项目的目录 ​ 1. 完善web项目的目录结构 ​ 修改web项目的根路径 配置项目的属性 ​ 配置项目资源的路径和返回页面的类型 #配置返回页面的前缀 spring.mvc.view.prefix=/ #配置返回页面的后缀 spring.mvc.view.suffix=.jsp 创建控制器和返回页面 @Controller public class IndexController &#123; @RequestMapping(&quot;/&quot;) public ModelAndView indexPage() &#123; ModelAndView mv = new ModelAndView(&quot;index&quot;); List&lt;Books&gt; books = new ArrayList&lt;&gt;(); books.add(new Books(1,&quot;springboot&quot;,22.00)); books.add(new Books(2,&quot;spring&quot;,44.00)); books.add(new Books(3,&quot;mybatis&quot;,33.00)); mv.addObject(&quot;books&quot;,books); return mv; &#125; &#125; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;welcome&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;单价&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;books&#125;&quot; var=&quot;book&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.title&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; ​ 注意：可能无法找到项目页面（报status：404） ​ 九、拦截器 1. Spring中的拦截器 ​ spring中的拦截器必须实现HandlerInterceptor接口 preHandle(HttpServletRequest request,HttpServletResponse response,Object handler)方法 ​ 作用：进行拦截处理 ​ 执行的时机：在控制器方法执行前执行 postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)方法 ​ 作用：进行相应处理 ​ 执行的时机：在控制器执行完成后，但没有对客户返回响应的时候 afterCompletion(HttpServletRequest request,HttpServletResponse response, Object handler, @Nullable Exception ex) ​ 作用：释放资源 ​ 执行的时机：在中央控制器完全处理完请求，已经将响应页面发送给客户时 2. SpringBoot中的拦截器 创建自定义拦截器，必须要实现HandlerInterceptor接口 /* 自定义拦截器 */ public class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //判断是否有用户登录 HttpSession session = request.getSession(); //获取登录的用户 Object loginUser = session.getAttribute(&quot;loginUser&quot;); //判断是否有用户 if(null == loginUser) &#123; //设置提示信息 request.setAttribute(&quot;msg&quot;,&quot;用户没有登陆,请先登录&quot;); //跳转页面 request.getRequestDispatcher(&quot;/&quot;).forward(request,response); return false;//被拦截 &#125; return true;//放行 &#125; &#125; 注册自定义的拦截器 ​ 创建一个配置类，必须实现WebMvcConfigurer接口，实现addInterceptors方法 @Configuration public class MyConfig implements WebMvcConfigurer &#123; /* 重写注册拦截器的方法 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; //设置拦截的路径 String[] addPathPatterns = &#123;&quot;/login&quot;,&quot;/main&quot;&#125;;//要连接的请求路径 //设置放行的路径 String[] excludePathPatterns = &#123;&quot;/&quot;,&quot;/login&quot;&#125;;//放行的路径 /* * 添加拦截器 * addPathPatterns -&gt; 添加拦截路径 * excludePathPatterns -&gt; 添加放行路径 * */ registry.addInterceptor(new MyInterceptor()).addPathPatterns(addPathPatterns).excludePathPatterns(excludePathPatterns); &#125; &#125; 十、异常处理 1. SpringBoot异常处理机制 ​ SpringBoot默认的异常处理都是映射到&#x2F;error路径上的 ​ 机器客户端：SpringBoot异常处理响应的十一个JSON数据 ​ 浏览机器客户端：SpringBoot异常处理响应的是一个错误页面 ​ 要自定义异常处理，需要添加一个View视图解析 2. 异常处理的自动装配 ​ 在SpringBoot中的ErrorMvcAutoConfiguration类，此类中自动配置了异常处理规则 ​ 组件：public BasicErrorController basicErrorController(ErrorAttributes errorAttributes,ObjectProvider errorViewResolvers) ​ 作用：处理默认的&#x2F;error路径的请求，响应错误的页面（error页面） ​ 组件：public View defaultErrorView() ​ 作用：响应默认的错误页面 ​ 组件：public BeanNameViewResolver beanNameViewResolver &gt; 视图解析器 ​ 作用：按照视图名去容器中找View对象 ​ 组件：DefaultErrorViewResolver conventionErrorViewResolver() &gt; 默认错误视图解析器 ​ 作用：发生错误时，会根据http的状态码作为视图的地址查找错误页面 ​ 组件：public DefaultErrorAttributes errorAttributes() ​ 作用：定义错误页面中可以包含的数据 3. 异常处理 使用@ExceptionHandler注解进行异常处理 ​ 在控制器中处理异常的方法，并使用@ExceptionHandler注解标识 /* 定义异常处理的方法 */ @ExceptionHandler(value = Exception.class) public String exceptionHandler(Exception e)&#123; return &quot;服务器异常，请与管理员联系！&quot;; &#125; ​ @ExceptionHandler注解的作用： ​ 标识此方法处理的时什么异常 ​ 标识此方法处理的是什么异常 将异常放置在父类中处理 ​ 创建父类 /* 所有控制器的父类 作用：统一处理异常 */ public class BaseController &#123; @ExceptionHandler(value = Exception.class) public ModelAndView defaultErrorHandler(Exception e) &#123; ModelAndView mv = new ModelAndView(); mv.addObject(&quot;message&quot;,e.getMessage()); mv.addObject(&quot;status&quot;,102); mv.setViewName(&quot;error&quot;); return mv; &#125; &#125; ​ 所有的控制器继承父类 @Controller public class IndexController extends BaseController &#123; @GetMapping(&quot;/&quot;) public String index()&#123; return &quot;index&quot;; &#125; @GetMapping(&quot;/hello&quot;) @ResponseBody public String hello() &#123; int i = 10 / 0; return &quot;hello&quot;; &#125; /* 定义异常处理的方法 */ @ExceptionHandler(value = Exception.class) public String exceptionHandler(Exception e)&#123; return &quot;服务器异常，请与管理员联系！&quot;; &#125; &#125; 使用 @ControllerAdvice + @ExceptionHandler 注解处理 /* 全局异常处理器 */ @ControllerAdvice public class GlobalExceptionHandler &#123; @ExceptionHandler(value = Exception.class) @ResponseBody public Object globalException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,100); map.put(&quot;message&quot;,e.getMessage()); return map; &#125; &#125; 十一、文件上传 1. 文件上传的三要素 表单中必须有文件域（type&#x3D;file） 表单提交方式必须是 post 方式 表单的 enctype 属性必须是多部份表单形式（entype&#x3D;”multipart&#x2F;form-data”） 2. 文件上传的实现 ​ SpringBoot 中的文件上传自动装配配置到 MultipartAutoConfiguration 类中 ​ 文件上传的配置信息： @Bean @ConditionalOnMissingBean(&#123;MultipartConfigElement.class, CommonsMultipartResolver.class&#125;) public javax.servlet.MultipartConfigElement multipartConfigElement() &#123; /* compiled code */ &#125; ​ 文件上传解析器 @Bean(name = &#123;&quot;multipartResolver&quot;&#125;) @ConditionalOnMissingBean(&#123;MultipartResolver.class&#125;) public StandardServletMultipartResolver multipartResolver() &#123; StandardServletMultipartResolver multipartResolver = new StandardServletMultipartResolver(); multipartResolver.setResolveLazily(this.multipartProperties.isResolveLazily()); return multipartResolver; &#125; ​ 文件上传实现 ​ 表单 &lt;body&gt; &lt;form th:action=&quot;@&#123;/upload&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 简历：&lt;input type=&quot;file&quot; multiple name=&quot;uploadFiles&quot;/&gt;&lt;br/&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; ​ 控制器 @Controller public class IndexController &#123; @GetMapping(&quot;/&quot;) public String indexPage() &#123; return &quot;welcome&quot;; &#125; @PostMapping(&quot;/upload&quot;) public ModelAndView uploadFile(MultipartFile[] uploadFiles, HttpServletRequest request) throws IOException &#123; //多文件上传 ModelAndView mv = new ModelAndView(&quot;main&quot;); List&lt;Uploads&gt; uploadsList = new ArrayList&lt;&gt;(); String path = request.getServletContext().getRealPath(&quot;/upload/&quot;); System.out.println(&quot;path=====&gt;&quot; + path); if (uploadFiles.length &gt; 0) &#123; for (MultipartFile uploadFile : uploadFiles) &#123; String filename = uploadFile.getOriginalFilename(); File file = new File(path,filename); if(!file.getParentFile().exists())&#123; file.getParentFile().mkdirs(); &#125; uploadFile.transferTo(file); uploadsList.add(new Uploads(filename,uploadFile)); &#125; &#125; mv.addObject(&quot;list&quot;,uploadsList); // //判断是否有文件上传 // if(!uploadFile.isEmpty())&#123; // //文件上传操作 // //设置文件保存的路径 // String path = request.getServletContext().getRealPath(&quot;/upload/&quot;); // System.out.println(&quot;path=====&gt;&quot;+path); // //获取文件名 // String filename = uploadFile.getOriginalFilename(); // //创建文件对象 // File file = new File(path,filename); // //判断保存文件的路径是否存在 // if(!file.getParentFile().exists())&#123; // file.getParentFile().mkdirs(); // &#125; // //保存文件 // uploadFile.transferTo(file); // &#125; // mv.addObject(&quot;username&quot;,username); // mv.addObject(&quot;fileName&quot;,uploadFile.getOriginalFilename()); return mv; &#125; &#125; 十二、数据访问 1. JPA 介绍 ​ JPA(Java Persistence API)是java持久化规范；是通过JDK5.0注解或xml描述对象-关系表映射关系，并将运行期的实体对象持久化到数据库中 2. Spring Data JPA ​ Spring Data JPA 是 Spring Data 中的一部分，可以轻松实现基于 JPA 的存储库。 ​ Spring Data JPA 用于处理基于 JPA 的数据访问层的增强。 ​ JPA 是 ORM 规范，Hibernate、MyBatis 都是 JPA 规范的具体实现 3. JPA 数据操作 ​ spring data 是通过 Repository 接口来预定数据访问的统一标准 @Indexed public interface Repository &lt;T, ID&gt; &#123; &#125; ​ 引入约束 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; ​ CrudRepository 接口提供了最基本的对实体类的操作 ​ 2. 创配置数据库信息和 JPA 信息 # 应用名称 spring.application.name=spring_jpa #配置数据信息 spring.datasource.url=jdbc:mysql://localhost:3306/crm?serverTimezone=Asia/Shanghai spring.datasource.username=root spring.datasource.password=123456 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #配置JPA信息 #配置要操作的数据库类型 spring.jpa.database=mysql #是否在日志中显示执行的sql语句 spring.jpa.show-sql=true #配置自动创建更新数据表 #update -&gt; 在操作时验证表是否存在，当不存在时创建表 spring.jpa.hibernate.ddl-auto=update ​ 3. 创建 Dao 层接口，继承 CrudRepository 接口 ​ 注：CrudRepository接口中定义了操作数据的统一方法，自定义的接口中可以不用定义任何方法 /* 接口中的泛型 第一个参数：要操作的实体对象 第二个参数：主键的数据类型 */ public interface UserRepository extends CrudRepository&lt;Users,Integer&gt; &#123; &#125; 创建业务层接口的实现类 ​ 注：在实现类中自动注入数据访问层 //接口 public interface UserService &#123; /* Iterable是一个array */ Iterable&lt;Users&gt; findAll(); &#125; //实现类 @Service(&quot;UserService&quot;) public class UserServiceImpl implements UserService &#123; @Autowired private UserRepository userRepository; @Override public Iterable&lt;Users&gt; findAll() &#123; return userRepository.findAll(); &#125; &#125; ​ 5. 创建控制器 @RestController public class IndexController &#123; @Autowired private UserService service; @GetMapping(&quot;/&quot;) public Object findAll()&#123; return service.findAll(); &#125; &#125; 4. 使用 PagingAndSortingRepository 接口操作数据 ​ PagingAndSortingRepository 接口继承了 CrudRepository 接口；具有 CrudRepository 接口的所有功能同时新增了分页排序功能 ​ 数据访问层 public interface UserPageRepository extends PagingAndSortingRepository&lt;Users,Integer&gt; &#123; &#125; ​ 业务层 //接口 public interface UserService &#123; //排序 Iterable&lt;Users&gt; findAllSort(); //分页 Page&lt;Users&gt; findAllPage(Integer pageIndex); &#125; //实现类 @Service(&quot;UserService&quot;) public class UserServiceImpl implements UserService &#123; @Autowired private UserPageRepository userPageRepository; //排序 @Override public Iterable&lt;Users&gt; findAllSort() &#123; //设置排序对象 /* by() -&gt; 创建排序对象 参数： 第一个参数：排序规则（升序或降序） 第二个参数：排序的列 */ Sort sort = Sort.by(Sort.Direction.DESC,&quot;id&quot;); return userPageRepository.findAll(sort); &#125; @Override public Page&lt;Users&gt; findAllPage(Integer pageIndex) &#123; /* 设置分页信息 PageRequest.of() -&gt; 设置分页属性 第一个参数：当前页数，从零开始 第二个参数：页面大小 第三个参数：排序对象（可以省略） */ Pageable pageable = PageRequest.of(pageIndex-1,2); return userPageRepository.findAll(pageable); &#125; &#125; 5. 使用JpaRepository接口数据访问 ​ JpaRepository接口继承了PagingAndSortingRepository接口 ​ 如果要自定义的条件查询，方法的命名必须以实体类的属性结尾；如果是模糊查询关键字 “like” 在方法名最后 //数据访问层 public interface UserJpaRepository extends JpaRepository&lt;Users,Integer&gt; &#123; //条件查询 //方法名不能随意命名 //方法名时，要使用实体类中的属性 Users findByUsername(String username); //模糊查询 //select * from t_user where username like %zhangsan% List&lt;Users&gt; findByUsernameLike(String username); &#125; 6. 使用JdbcTemplate操作数据 ​ JdbcTemplate：Spring对JDBC操作的进一步封装，是Spring操作数据的核心对象 ​ 常用方法： ​ execute方法：可以执行任意的SQL语句，一般用于执行DDL语句 ​ update方法：用于执行增、删、改语句 ​ query方法和queryForXXX方法：执行查询操作 ​ call方法：用于执行存储过程 引入依赖 &lt;!--引入jdbc依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; 配置数据源 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据源名称 spring.datasource.name=dataSource # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/crm?serverTimezone=Asia/Shanghai # 数据库用户名&amp;密码： spring.datasource.username=root spring.datasource.password=123456 创建实体类 ​ 注意：实体类属性名同名 @Data @NoArgsConstructor @AllArgsConstructor public class Users &#123; private int id; private String user_name; private String email; private String true_name; &#125; 创建数据访问层接口和实现类 ​ 注意：自动注入JdbcTemplate //接口 public interface UserRepository &#123; List&lt;Users&gt; findAll(); &#125; //实现类 @Repository//标识本类是数据访问层 public class UserRepositoryImpl implements UserRepository &#123; //引入了jdbc的依赖，在容器中注册了JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; @Override public List&lt;Users&gt; findAll() &#123; //创建要执行的SQL语句 String sqlText = &quot;select * from t_user&quot;; //确定数据行与实体类的映射关系 RowMapper&lt;Users&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Users.class); return jdbcTemplate.query(sqlText,rowMapper); &#125; &#125; 业务层的接口和实现类 //接口 public interface UserService &#123; List&lt;Users&gt; findAll(); &#125; //实现类 @Service(&quot;UserService&quot;) public class UserServiceImpl implements UserService &#123; @Autowired private UserRepository repository; @Override public List&lt;Users&gt; findAll() &#123; return repository.findAll(); &#125; &#125; 控制器 @RestController public class UserController &#123; @Autowired private UserService service; @GetMapping(&quot;/&quot;) public Object findAll()&#123; List&lt;Users&gt; users = service.findAll(); return users; &#125; &#125; 7. SpringBoot 整合 Druid 数据源 自定义整合 Druid 数据源 ​ a. 引入 Druid 数据源的依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; ​ b. 创建配置类 ​ 将 Durid 数据源注入到容器中 /* Druid数据源的配置类 */ @Configuration public class DruidConfig &#123; @Bean //注册组件 @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) public DataSource dataSource() &#123; //创建Druid数据源 DruidDataSource druidDataSource = new DruidDataSource(); return druidDataSource; &#125; &#125; ​ c. 配置数据源的属性 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据源名称 spring.datasource.name=spring_datasource # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/crm?serverTimezone=Asia/Shanghai # 数据库用户名&amp;密码： spring.datasource.username=root spring.datasource.password=123456 使用 SpringBoot 的场景整合 Druid 数据源 ​ 引入 Druid 的场景 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; ​ 注意：Druid数据源的场景引入后，已经完成了自动装配 十三、SpringBoot 整合 MyBatis ​ springboot 整合 MyBatis 和 Spring 整合MyBatis是相同的。SpringBoot 作为快速搭建基于Spring框架的一个工具，封装了 Spring 框架中的所有组件。因此可以采用整合 Spring 整合 MyBatis 的方法进行整合 ​ 整合步骤： 引入依赖 编写配置进行整合 ​ a). 配置数据源 ​ b). 配置 SqlSessionFactoryBean ​ c). 配置 MapperScannerConfigurer 1. 采用 Spring 整合 MyBatis 方式 引入依赖 &lt;!--引入依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; 配置数据源 ​ 由于引入了spring-boot-starter-data-jdbc ，所以在SpringBoot中已经自动配置了数据源 ​ 要提供数据源配置的属性 #配置数据源属性 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://127.0.0.1:3306/crm?serverTimeZone=Asia/Shanghai spring.datasource.username=root spring.datasource.password=123456 配置SqlSessionFactoryBean ​ 由于SpringBoot中没有XML文件，要将 /* 配置SqlSessionFactory */ @Configuration public class SqlSessionFactoryConfig &#123; //注入数据源 @Autowired private DataSource dataSource; //注入SqlSessionFactoryBean组件 @Bean public SqlSessionFactory sqlSessionFactoryBean() throws Exception &#123; //创建SqlSessionFactoryBean组件 SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); //配置数据源 sqlSessionFactoryBean.setDataSource(dataSource); //配置别名 sqlSessionFactoryBean.setTypeAliasesPackage(&quot;com.jbit.pojo&quot;); return sqlSessionFactoryBean.getObject(); &#125; &#125; 配置MapperScannerConfigurer /* 配置MapperScannerConfigurer */ public class MapperScannerConfig &#123; /* 注入Mapper扫描组件 */ @Bean public MapperScannerConfigurer mapperScannerConfigurer() &#123; //创建Mapper扫描器 MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); //配置SqlSessionFactory mapperScannerConfigurer.setSqlSessionFactoryBeanName(&quot;sqlSessionFactoryBean&quot;); //配置Mapper扫描路径 mapperScannerConfigurer.setBasePackage(&quot;com.jbit.dao&quot;); return mapperScannerConfigurer; &#125; &#125; 实体类、Mapper 接口、Mapper 映射文件、业务层接口、业务层实现类、控制器与原来的代码一样 2. 采用 SpringBoot 场景整合 引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; ​ 编写配置进行整合 ​ a). 配置数据源 ​ 由于引入了 JDBC 场景，SpringBoot 自动配置好了数据源 ​ b). 配置 SqlSessionFactoryBean @Bean @ConditionalOnMissingBean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123; /* compiled code */ &#125; ​ SpringBoot 自动配置了（SqlSessionTemplate &#x3D;&gt; 就是 SqlSession） ​ c). 配置 MapperScannerConfigurer ​ SpringBoot 自动配置了 MapperScannerConfigurer @Configuration @Import(&#123;AutoConfiguredMapperScannerRegistrar.class&#125;) @ConditionalOnMissingBean(&#123;MapperFactoryBean.class,MapperScannerConfigurer.class&#125;) public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean &#123; &#125; 配置配置文件、给数据源和 MaBatis 的属性设置值 # 数据库驱动： spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # 数据源名称 spring.datasource.name=defaultDataSource # 数据库连接地址 spring.datasource.url=jdbc:mysql://localhost:3306/crm?serverTimezone=Asia/Shanghai # 数据库用户名&amp;密码： spring.datasource.username=root spring.datasource.password=123456 #配置MyBatis的属性 #配置映射文件的位置 mybatis.mapper-locations=classpath:com/jbit/dao/*.xml #配置别名 mybatis.type-aliases-package=com.jbit.pojo #配置MyBatis的核心配置文件位置 #mybatis.config-location= #配置日志输出（显示SQL语句） mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 实体类、Mapper 接口、Mapper 映射文件、业务层接口、业务层实现类、控制器与 SSM 项目一样","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"}]},{"title":"Git项目管理工具","slug":"Git项目管理工具","date":"2022-07-18T07:23:57.000Z","updated":"2022-07-18T09:24:07.057Z","comments":true,"path":"2022/07/18/Git项目管理工具/","link":"","permalink":"http://example.com/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/","excerpt":"Git项目管理工具","text":"Git项目管理工具 学习 git 之前，我们需要先明白一个概念，版本控制 版本控制 什么是版本控制 版本控制（Revision control）是一种在开发过程种用于管理我们对文件、目录或工程内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。 实现跨区域多人协同开发 追钟和记载一个或者多个文件的历史记录 组织保护你的源代码和文档 统计工作量 并行开发、提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间，同时降低认为错误 简单说就是用于管理多人协同开发项目的技术。 没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程种将会引入很多问题，如软件代码的一致性、软件内容冗余、软件过程的事务性、软件开发过程中的并发性、软件代码的安全性，以及软件的整合等问题。 无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们迫切需要一个版本控制工具！ 多人开发就必须使用版本控制，都在代价会比较大！ 常见版本控制工具 主流的版本控制器有如下这些： Git SVN（Subversion） CVS（Concurrent Versions System） VSS（Micorosoft Visual SourceSafe） TFS（Team Foundation Server） Visual Studio Online 版本控制产品非常的多（Preforce、Rational Clearcase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git和SVN 版本控制分类 1、本地版本控制 记录文件每次的更新，可以对每个版本做一个快照，或者是记录补丁文件，适合个人用，如 RCS。 ​ 2、集中版本控制 SVN 所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改 ​ 所有对的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不联网的话，用户就看不到历史版本，也无法切换版本验证问题或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS 3、分布式版本控制 Git 每个人都拥有全部代码！安全隐患！ 所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在联网时 push 到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地储存空间的占用。 ​ Git 与 SVN 最主要的区别 SVN 试集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作的，对网络宽带要求较高。 Git 是分布式版本控制器系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 Git 是目前世界上最先进的分布式版本控制系统 聊聊 Git 历史 同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。 Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991 - 2002年间)。到2002年，整个项目组开始启用一个专有的分布式版本控制系统BitKeeper来管理和维护代码。 到了2005年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。也就是后来的 Git！ Git 时目前世界上最先进的分布式版本控制系统。 Git 是免费、开源的，最初 Git 是为辅助 Linux 内核开发的，来代替BitKeeper！ Linux 和 Git 之父利纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰 Git 环境配置 先卸载 直接反安装即可、然后清理环境变量，环境变量只是为了全局使用而已！ 软件下载 打开【git官网】https://git-scm.com/，下载 git 对应操作系统的版本。 官网下载太慢，我们可以使用淘宝镜像下载：http://npm.taobao.org/mirrors/git-for-windows/ 下载对应的版本安装即可安装！ 安装：无脑下一步即可！安装完毕就可以使用了！ 启动Git 安装完成后在开始菜单中会有 Git 项，菜单下有3个程序：任意文件夹下右键耶可以看到对应的程序！ ​ Git Bash：Unix 与 Linux 风格的命令行，使用最多，推荐最多 Git CMD：Windows 风格的命令行 Git GUI：图形界面的 Git ，不建议初学者使用，尽量先熟悉常用命令 基本的 Linux 命令学习 cd：改变目录 cd ..：回退到上一个目录，直接cd进入默认的目录 pwd：显示当前所在的目录路径 ls(ll)：都是列出当前目录中的所有文件，只不ll（两个ll）列出的内容更加详细 touch：新建一个文件如 touch index.js 就会在当前目录下新建一个index.js文件 rm：删除一个文件，rm index.js 就会把 index.js文件删除 mkdir：新建一个目录，就是新建一个文件夹 rm -r：删除一个文件夹，rm -r src 删除src目录 rm -rf &#x2F; 切勿在Linux中尝试！删除电脑中全部文件！ mv 移动文件，mv index.jhtml src index.html 是我们要移动的文件，src是目标文件夹，当然，这样写，必须保证文件和目标文件夹在同一目录下 reset：重新初始化终端&#x2F;清屏 clear：清屏 history：查看命令历史 help：帮助 exit：推出 #表示注释 Git 配置 查看配置 git config -l ​ 查看不同级别的配置文件： #查看系统config git config --system --list #查看当前用户（global）配置 git config --global --list Git 相关的配置文件 ​ 1. Git\\etc\\gitconfig：Git 安装目录下的 gitconfig –system 系统级 ​ ​ 2. C:\\Users\\Administrator.gitconfig 只适用当前登录用户的配置 –global 全局 ​ 这里可以直接编辑配置文件，通过命令设置后会响应到这里。 设置用户名与邮箱（用户标识，必要） 当你安装 Git 后首先要做的事情是设置你的用户名称和 e-mail 地址。这是非常重要的，因为每次 Git 提交都会使用该信息。它被永远的嵌入到了你的提交中： git config --global user.name &quot;用户名&quot; #名称 git config --global user.email &quot;邮箱&quot; #邮箱 只需要做一次这个设置，如果你传递了 –global 选项，因为 Git 将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同名称或 e-mail 地址，你可以在该项目中运行该命令而不要 –global 选项。总之 –global 为全局配置，不加为某个项目的特定配置。 ​ Git 基本理论（核心） 工作领域 Git 本地有三个工作领域：工作目录（Working Directory）、暂存区（Stage&#x2F;Index）、资源库（Repository 或 Git Directory）。如果在加上远程的 git 仓库（Remote Directory）就可以分为四个工作领域。文件在这四个区域之间的转换关系如下： ​ Workspace：工作区，就是你平时存放项目代码的地方 Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中 HEAD 指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换本地三个区域确切的说应该是 git 仓库中 HEAD 指向的版本： ​ Directory：使用 Git 管理的一个目录，也就是一个仓库，包含我们的工作空间和 Git 的管理空间 WorkSpace：需要通过 Git 进行版本控制的目录和文件，这些目录和文件组成了工作空间 .git：存放 Git 管理信息的目录，初始化仓库的时候自动创建 Index&#x2F;Stage：暂存区，或者叫待提交更新区，在提交进入 repo 之前，我们把所有的更新放在暂存区 Local Repo：本地仓库，一个放在本地的版本库；HEAD会只是当前的开发分支（branch） Stash：隐藏，是一个工作状态保存栈，用于保存&#x2F;恢复 WorkSpace 中的临时状态 工作流程 git 的工作流程一般是这样的： 在工作目录中添加、修改文件 将需要进行版本管理的文件放入暂存区域 将暂存区域的文件提交到 git 仓库 因此，git 管理的文件有三种状态：已修改（modified），已暂存（staged），已提交（committed） ​ Git 项目搭建 创建工作目录与常用指令 工作目录（WorkSpace）一般就是希望 Git 帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。 日常使用只要记住下图6个命令： ​ 本地仓库搭建 创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。 1、创建全新的仓库，需要用 Git 管理的项目的根目录执行； #在当前目录新建一个 Git 代码库 $ git init 2、执行后可以看到，仅仅在项目目录多出了一个 .git 目录，关于版本等的所有信息都在这个目录里面。 克隆远程仓库 1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！ #克隆一个项目和它的整个代码历史（版本信息） $ git clone [url] 2、去 gitte 或者 github 上克隆一个测试！ Git 文件操作 文件4种状态 版本控制就是对文件的版本控制，要对文件进行修改，提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 Untracked：未跟踪，此文件在文件夹中，但并没有加入到 git 库，不参与版本控制。通过 git add 状态变为 Staged Unmodify：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致，这种类型的文件有两种去处，如果它被修改，而变为 Modified 。如果使用 git crm 移出版本库，则成为 Untracked 文件 Modified：文件已修改，仅仅是修改，并没有进行其他的操作，这个文件也有两个去处，通过 git add 可进入暂存 Staged 状态，使用 git checkout 则丢弃修改过，返回到 unmodify 状态，这个 git checkout 即从库中取出文件，覆盖当前修改！ Staged：暂存状态，执行 git commit 则将修改同步到库中，这时候库中的文件和本地文件又变为一致，文件为 Unmodify 状态。执行 git reset HEAD filename 取消暂存，文件状态为 Modified 查看文件状态 上面说文件有4种状态，通过如下命令可以查看到文件状态： #查看指定文件状态 git status [filename] #查看所有文件状态 git status #添加所有文件到暂存区 git add . #提交暂存区中的内容到本地仓库 -m 提交信息 git commit -m &quot;消息内容&quot; 忽略文件 有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立 “gitignore” 文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略 可以使用 Linux 通配符。例如：星号（*）代表任意多个字符，问号（?）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,….}）代表可选的字符串等 如果名称的最前面有一个感叹号（!），标识列外规则，将不被忽略 如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略 如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略） #为注释 *.txt #忽略所有 !lib.txt #但lib.txt除外 /temp #仅忽略项目根目录下的TODO文件，不包括其他目录temp build/ #忽略build/目录下的所有文件 doc/*.txt #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 使用码云 github是有墙的，比较慢，在国内的话，我们一般使用gitee，有时候会搭建gitlab服务器 1、注册登录码云，完善个人信息 2、设置本机绑定SSH公钥，实现免密码登录！ #进入 C:\\Users\\Administrator\\.ssh 目录 #生成公钥 ssh-keygen 3、将公钥信息public key 添加到码云账户中即可！ 4、使用码云创建一个自己的仓库！ IDEA 集成 Git 1.新建项目，绑定 git 将我们远程的 git 文件目录拷贝到项目中即可！ 2.修改文件，使用 IDEA 操作 git 3.提交测试 说明：GIT 分支 分支在 Git 中相对较难，分支就是科幻电影的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理问题了！ ​ git 分支中常用指令： # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 合并指定分支到当前分支 $ git merge [branch] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 如果多个分支并行执行，就会导致我们代码不冲突，也就是同时存在多个版本！ 如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！ master 主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的 dev 分支上工作，工作完后，比如上要发布，或者说 dev 分支代码稳定后可以合并到主分支 master 上来","categories":[{"name":"Tool","slug":"Tool","permalink":"http://example.com/categories/Tool/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"开发常见问题","slug":"开发常见问题","date":"2022-07-12T07:45:52.000Z","updated":"2022-08-11T10:16:01.268Z","comments":true,"path":"2022/07/12/开发常见问题/","link":"","permalink":"http://example.com/2022/07/12/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","excerpt":"我们在做开发的时候经常会遇见各种各样的问题，分享一下我遇到的一些问题以及解决办法","text":"我们在做开发的时候经常会遇见各种各样的问题，分享一下我遇到的一些问题以及解决办法 windows 系统启动服务时出现报错 1.Windows启动服务出现错误“并非所有的功能被成功更改” 的问题 按 “Windows 徽标键+X”，启动 “Windows PowerShell（管理员）”，输入以下命令： Dism /Online /Cleanup-Image /ScanHealth 这条命令将扫描全部系统文件并和官方系统文件对比，扫描计算机中的不一致情况 Dism /Online /Cleanup-Image /CheckHealth 这条命令必须在前一条命令执行完以后，发现系统文件有损坏时使用 DISM /Online /Cleanup-image /RestoreHealth 这条命令是把那些不同的系统文件还原成官方系统源文件 无论前三条命令是否可用，完成后重启，再键入以下命令： sfc /SCANNOW maven 常见问题有的时候需要将一些自己封装的包放入本地仓库进行程序打包，可以是由 mvn 指令将包放入本地仓库 //将本地文件放入本地仓库，仓库的位置跟你本地的 settings.xml 配置有关 mvn install:install-file -Dfile=D:\\company\\encrypt_sdk.jar -DgroupId=encrypt_sdk -DartifactId=encrypt_sdk -Dversion=1.0 -Dpackaging=jar idea maven 插件打包报错不知道怎么解决，可以尝试将依赖从本地仓库移除重新下载，或者使用 mvn 打包指令 //mvn 打包进入调试模式，会有比较详细的报错信息，应该能帮助你找到问题 mvn package -x 前端传参常见问题 参数格式化（数组），前端请求后端 api 带数组参数比较特殊不做处理可能导致后端无法正常接收到参数 //vue axios请求 paramsSerializer: params =&gt; &#123; return qs.stringify(params, &#123; indices: false &#125;) &#125; //ajax 请求 添加traditional 请求参数为 true, 也可以将参数转换为 json 再传递 $.ajax(&#123; url: &#39;apiurl&#39;, data: data[], type: &#39;post&#39;, traditional:true， success: res =&gt; &#123; //代码省略... &#125;, error: err =&gt; &#123; //代码省略... &#125; &#125;) Cookie 当浏览器存在 cookie 时向 api 发送请求会自动将 cookie 带入请求（统一域名） 注：特定情况下会自动将cookie带入请求头部 依赖排除 ​ 例：由于 log4j 2.17 版本以下出现高危漏洞，springboot-stater 依赖整合了 log4j 依赖如果直接去除会导致项目无法运行，建议更换 2.17.1 版本 &lt;!-- 2.17.0修复漏洞版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.17.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.17.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.17.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; npm 清理缓存 web前端可能由于网络波动造成下载超时，npm缓存未清理造成依赖下载失败，解决（清理 npm 缓存） npm cache clean --force 查看 npm 缓存的位置 npm cache dir 可能由于版本问题无法执行上一条指令，可以尝试下面这条 npm config list --json CMD指令CMD端口指令查看端口（根据端口号）： netstat -aon|findstr &quot;端口号&quot; 查看端口（全部）： netstat -ano 杀死端口（根据pid）： taskkill /pid &quot;pid&quot; Vue 中监听浏览器关闭和刷新事件 beforeunload 页面关闭或刷新之前 （可逆：可阻止页面刷新或关闭） unload 页面关闭或刷新之后（不可逆：无法阻止页面刷新或关闭） 在浏览器关闭前是无法判断用户是刷新还是退出，所以我们在用户再次打开的时候来判断用户是否刷新 解决思路： 1.用户关闭浏览器时，记录当前时间，并存于浏览器缓存中 2.用户再次打开页面时，获取上次退出的时间，并于当前时间进行比较，若小于5s则表示用户执行的是刷新操作，若大 于5s则判定为退出 注意： 5s并非固定，要根据实际情况调整 //javascript 代码 // 进入页面执行 // 记录当前时间并转成时间戳 const now = new Date().getTime(); // 从缓存中获取用户上次退出的时间戳 const leaveTime = parseInt(localStorage.getItem(&#39;leaveTime&#39;), 10); // 判断是否为刷新，两次间隔在5s内判定为刷新操作 const refresh = (now - leaveTime) &lt;= 5000; // 测试alert alert(refresh ? &#39;刷新&#39; : &#39;重新登陆&#39;); // 退出当前页面执行 window.onunload = function(e)&#123; // ios 不支持 window.onbeforeunload() // 将退出时间存于localstorage中 localStorage.setItem(&#39;leaveTime&#39;, new Date().getTime()); &#125; //Vue 代码 mounted:&#123; window.addEventListener(&#39;beforeunload&#39;, e =&gt; this.beforeunloadFn()) window.addEventListener(&#39;unload&#39;, e =&gt; this.unloadFn()) &#125;, methods:&#123; unloadFn()&#123; this._gap_time=new Date().getTime()-this._beforeUnload_time if(this._gap_time &lt;= 5)&#123; //浏览器关闭执行的代码块 &#125; &#125;, beforeloadFn()&#123; thi._beforeUnload_time=new Date().getTime() &#125; &#125;, destroyed:&#123; window.removeEvenListener(&#39;beforeunload&#39;,e =&gt; this.beforeloadFn()) window.removeEvenListener(&#39;unload&#39;,e =&gt; this.unloadFn()) &#125; 开发时经常有端口被占用的情况 windows解决方法 查看端口（根据端口号） netstat -aon|findstr &quot;端口号&quot; 查看端口（全部） netstat -ano 杀死端口（根据pid） taskkill /pid &quot;pid&quot;","categories":[{"name":"常见问题","slug":"常见问题","permalink":"http://example.com/categories/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"常见问题","slug":"常见问题","permalink":"http://example.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}]},{"title":"Postgresql数据库","slug":"Postgresql数据库","date":"2022-07-11T11:23:05.000Z","updated":"2022-07-18T07:28:38.531Z","comments":true,"path":"2022/07/11/Postgresql数据库/","link":"","permalink":"http://example.com/2022/07/11/Postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"Postgresql数据库是关系型数据库 下载地址： https://www.enterprisedb.com/downloads/postgres-postgresql-downloads","text":"Postgresql数据库是关系型数据库 下载地址： https://www.enterprisedb.com/downloads/postgres-postgresql-downloads WITH 查询 ​ WITH查询是PostgreSQL支持的高级SQL特性之一，这一特性常称为CTE(Common Table Expressions)，WITH查询在复杂查询中定义一个辅助语句（可理解成在一个查询中定义的临时表），这一特性常用于复杂查询或递归查询应用场景 with a as (select * from wp_dkbasedatainfo where xzqdm =&#39;650203&#39; ) select * from a ,b where a.tbflqk=&#39;实地伪变化&#39; ​ WITH 查询的一个重要属性是 RECURSIVE，使用 RECURSIVE 属性可以引用自己的输出，从而实现递归，一般用于层次结构或树状结构的应用场景 例如，存在一张包含如下数据的表： id name fatherid1 中国 02 辽宁 13 山东 14 沈阳 25 大连 26 济南 37 和平区 48 沈河区 4 使用PostgreSQL的WITH查询检索ID为7以及以上的所有父节点，如下： WITH RECURSIVE r AS ( SELECT * FROM test_area WHERE id = 7 UNION ALL SELECT test_area.* FROM test_area, r WHERE test_area.id = r.fatherid ) SELECT * FROM r ORDER BY id; 查询结果如下： id | name | fatherid----+--------+---------- 1 | 中国 | 0 2 | 辽宁 | 1 4 | 沈阳 | 2 7 | 和平区 | 4(4 rows) WITH RECURSIVE WITH 语句还可以通过增加 RECURSIVE 修饰符来引入它自己，从而实现递归 WITH RECURSIVE 一般用于处理逻辑上层次化或树状结构的数据，典型的使用场景是寻找直接及间接子结点 定义下面这样的表，存储每个区域（省、市、区）的 id，名字及上级区域的 id CREATE TABLE chinamap ( id INTEGER, pid INTEGER, name TEXT ); 需要查出某个省，比如湖北省，管辖的所有市及市辖地区，可以通过WITH RECURSIVE来实现，如下： WITH RECURSIVE result AS ( SELECCT id, name FROM chinamap WHERE id = 11 UNION ALL SELECT origin.id, result.name || &#39; &gt; &#39; || origin.name FROM result JOIN chinamap origin ON origin.pid = result.id ) SELECT id, name FROM result; 结果如下： id | name -----+-------------------------- 11 | 湖北省 110 | 湖北省 &gt; 武汉市 120 | 湖北省 &gt; 孝感市 130 | 湖北省 &gt; 宜昌市 140 | 湖北省 &gt; 随州市 150 | 湖北省 &gt; 仙桃市 160 | 湖北省 &gt; 荆门市 170 | 湖北省 &gt; 枝江市 180 | 湖北省 &gt; 神农架市 111 | 湖北省 &gt; 武汉市 &gt; 武昌区 112 | 湖北省 &gt; 武汉市 &gt; 下城区 113 | 湖北省 &gt; 武汉市 &gt; 江岸区 114 | 湖北省 &gt; 武汉市 &gt; 江汉区 115 | 湖北省 &gt; 武汉市 &gt; 汉阳区 116 | 湖北省 &gt; 武汉市 &gt; 洪山区 117 | 湖北省 &gt; 武汉市 &gt; 青山区 (16 rows) WITH RECURSIVE 执行过程 从上面的例子可以看出，WITH RECURSIVE语句包含了两个部分 non-recursive term（非递归部分），即上例中的union all前面部分 recursive term（递归部分），即上例中union all后面部分 执行步骤如下： 执行non-recursive term（如果使用的是union而非union all，则需对结果去重）其结果作为recursive term中对result的引用，同时将这部分结果放入临时的working table中 重复执行如下步骤，直到working table为空：用working table的内容替换递归的自引用，执行recursive term，（如果使用union而非union all，去除重复数据），并用该结果（如果使用union而非union all，则是去重后的结果）替换working table 以上面的query为例，来看看具体过程： 1.执行： SELECT id, nameFROM chinamapWHERE id = 11 结果集和 working table 为： 11 | 湖北 2.执行： SELECT origin.id, result.name || &#39; &gt; &#39; || origin.name FROM result JOIN chinamap origin ON origin.pid = result.id 结果集和 working table 为： 110 | 湖北省 &gt; 武汉市 120 | 湖北省 &gt; 孝感市 130 | 湖北省 &gt; 宜昌市 140 | 湖北省 &gt; 随州市 150 | 湖北省 &gt; 仙桃市 160 | 湖北省 &gt; 荆门市 170 | 湖北省 &gt; 枝江市 180 | 湖北省 &gt; 神农架市 3.再次执行recursive query，结果集和working table为： 111 | 湖北省 &gt; 武汉市 &gt; 武昌区 112 | 湖北省 &gt; 武汉市 &gt; 下城区 113 | 湖北省 &gt; 武汉市 &gt; 江岸区 114 | 湖北省 &gt; 武汉市 &gt; 江汉区 115 | 湖北省 &gt; 武汉市 &gt; 汉阳区 116 | 湖北省 &gt; 武汉市 &gt; 洪山区 117 | 湖北省 &gt; 武汉市 &gt; 青山区 4.继续执行recursive query，结果集和working table为空 5.结束递归，将前三个步骤的结果集合并，即得到最终的WITH RECURSIVE的结果集严格来讲，这个过程实现上是一个迭代的过程而非递归，不过RECURSIVE这个关键词是SQL标准委员会定立的，所以PostgreSQL也延用了RECURSIVE这一关键词 WITH RECURSIVE 防止死循环 ​ 从上一节中可以看到，决定是否继续迭代的working table是否为空，如果它永不为空，则该CTE将陷入无限循环中 对于本身并不会形成循环引用的数据集，无段作特别处理而对于本身可能形成循环引用的数据集，则须通过SQL处理 ​ 一种方式是使用UNION而非UNION ALL，从而每次recursive term的计算结果都会将已经存在的数据清除后再存入working table，使得working table最终会为空，从而结束迭代 ​ 然而，这种方法并不总是有效的，因为有时可能需要这些重复数据同时UNION只能去除那些所有字段都完全一样的记录，而很有可能特定字段集相同的记录即应该被删除此时可以通过数组（单字段）或者ROW（多字段）记录已经访问过的记录，从而实现去重的目的 WITH RECURSIVE 求最短路径 定义如下表并存入每条边的权重 CREATE TABLE graph ( id char, neighbor char, value integer ); INSERT INTO graph VALUES(&#39;A&#39;, &#39;B&#39;, 3), (&#39;A&#39;, &#39;C&#39;, 5), (&#39;A&#39;, &#39;D&#39;, 4), (&#39;B&#39;, &#39;E&#39;, 8), (&#39;B&#39;, &#39;C&#39;, 4), (&#39;E&#39;, &#39;C&#39;, 7), (&#39;E&#39;,&#39;F&#39;, 10), (&#39;C&#39;, &#39;D&#39;, 3), (&#39;C&#39;, &#39;F&#39;, 6), (&#39;F&#39;,&#39;D&#39;, 5); 计算思路如下： 因为是无向图，所以首先要将各条边的id和neighbor交换一次以方便后续计算 利用WITH RECURSIVE算出所有可能的路径并计算其总权重 因为该图有环，为避免无限循环，同时为了计算路径，将经过的结点存于数据中，当下一个结点已经在数据中时，说明该结点已被计算 最终可算出所有可能的路径及其总权重 实现如下： WITH RECURSIVE edges AS ( SELECT id, neighbor, value FROM graph UNION ALL SELECT neighbor, id, value FROM graph ), all_path (id, neighbor, value, path, depth, cycle) AS ( SELECT id, neighbor, value, ARRAY[id], 1, &#39;f&#39;::BOOLEAN FROM edges WHERE id = &#39;A&#39; UNION ALL SELECT all_path.id, edges.neighbor, edges.value + all_path.value, all_path.path || ARRAY[edges.id], depth + 1, edges.id = ANY(all_path.path) FROM edges JOIN all_path ON all_path.neighbor = edges.id AND NOT cycle ), a_f AS ( SELECT rank() over(order by value) AS rank, path || neighbor AS path, value, depth FROM all_path WHERE neighbor = &#39;F&#39; ) SELECT path, value, depth FROM a_f WHERE rank = 1; WITH RECURSIVE 使用限制 如果在recursive term中使用LEFT JOIN，自引用必须在“左”边 如果在recursive term中使用RIGHT JOIN，自引用必须在“右”边 recursive term中不允许使用FULL JOIN recursive term中不允许使用GROUP BY和HAVING 不允许在recursive term的WHERE语句的子查询中使用CTE的名字 不支持在recursive term中对CTE作aggregation recursive term中不允许使用ORDER BY LIMIT &#x2F; OFFSET不允许在recursive term中使用 FOR UPDATE不可在recursive term中使用 recursive term中SELECT后面不允许出现引用CTE名字的子查询 同时使用多个CTE表达式时，不允许多表达式之间互相访问（支持单向访问） 在recursive term中不允许使用FOR UPDATE CTE 优缺点 可以使用递归 WITH RECURSIVE，从而实现其它方式无法实现或者不容易实现的查询 当不需要将查询结果被其它独立查询共享时，它比视图更灵活也更轻量 CTE只会被计算一次，且可在主查询中多次使用 CTE可极大提高代码可读性及可维护性 CTE不支持将主查询中where后的限制条件push down到CTE中，而普通的子查询支持 2.数据库中的数据如果不存在则插入，存在则更新 INSERT INTO test_postgre(id,name,InputTime,age) VALUES(&#39;1&#39;,&#39;postgre&#39;,&#39;2018-01-10 22:00:00&#39;,24) ON conflict(id) DO UPDATE SET name = &#39;postgreOk&#39;, InputTime =&#39;2018-02-22 12:00:00&#39; 常用 SQL 语句 -- 如果表中存在了 id 这条数据则更新否则向表中插入数据 INSERT INTO test_postgre(id,name,InputTime,age) VALUES(&#39;1&#39;,&#39;postgre&#39;,&#39;2018-01-10 22:00:00&#39;,24) ON conflict(id) DO UPDATE SET name = &#39;postgreOk&#39;, InputTime =&#39;2018-02-22 12:00:00&#39; -- 如果 a.title 为空则取 b.title 的值 select coalesce(a.title,b.title) from a join b on a.pid = a.id -- 筛选 title 列为空的数据 select * from a where a.title is null -- 筛选 title 列为非空的数据 select * from a where a.title is not null -- case when 语句块的使用 select ( case when fwxz = &#39;0&#39; then &#39;市场化商品房&#39; when fwxz = &#39;1&#39; then &#39;动迁房&#39; when fwxz = &#39;2&#39; then &#39;配套商品房&#39; when fwxz = &#39;3&#39; then &#39;公共租赁住房&#39; when fwxz = &#39;4&#39; then &#39;廉租住房&#39; when fwxz = &#39;5&#39; then &#39;限价普通商品住房&#39; when fwxz = &#39;6&#39; then &#39;经济适用住房&#39; when fwxz = &#39;7&#39; then &#39;定销商品房&#39; when fwxz = &#39;8&#39; then &#39;集资建房&#39; when fwxz = &#39;9&#39; then &#39;福利房&#39; when fwxz = &#39;10&#39; then &#39;保障性住房&#39; when fwxz = &#39;11&#39; then &#39;房改房&#39; when fwxz = &#39;12&#39; then &#39;自建房&#39; when fwxz = &#39;99&#39; then &#39;其它&#39; else fwxz end ) as fwxz,count(*) from fwb_qjcg_hb group by fwxz -- 查询时去除重复的数据 select distinct name,phone from user -- 更新返回更新后列的数据 update &quot;user&quot; set username = &#39;aa&#39; returning username -- 插入表中某列的数据返回插入后的数据 insert into &quot;user&quot;(username) values(&#39;张三&#39;) returning username -- unnest 函数将输入的数组转换成一个表,这个表的每一列都代表相应的一个数组中的元素 select &#39;张三&#39; as name ,unnest(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) as course -- with ordinality 用于给返回的结果集增加一个整数列，这个整数列从1开始，并且按1递增 -- 注： with ordinality 必须使用在from子句中，且要紧跟在函数后面使用！ select * from unnest(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) with ordinality -- round 函数用于把数值字段舍入为指定的小数位数 -- 注：使用 round 函数时注意统一字段类型，可使用 as 或者 &#39;::&#39; 转换字段类型 select round(12.743874,2) -- random() 函数可以获取随机数，固定公式 random() * (num1 - num2)+num2 select random() * (100-1) + 1 --获取 1 ~ 100 以内的随机数 -- generate_series() 函数可以按不同的规则产生一系列的填充数据 -- generate_series(start, stop) 获取100个 1 ~ 100 以内的随机数 select (random() * (100-1) + 1) as num from generate_series(1,100) -- generate_series(start, stop, step) 生成一个数值序列，从start 到 stop，步进为step select generate_series(10,1,-1) -- generate_series(start, stop, step_interval) 生成一个数值序列，从start 到 stop，步进为step select generate_series(now(), now() + &#39;7 days&#39;, &#39;1 day&#39;) -- 创建序列 create sequence seq_user increment by 1 minvalue 1 no maxvalue start with 1 -- nextval() 函数递增序列并返回新值 select nextval(seq_user)","categories":[{"name":"database","slug":"database","permalink":"http://example.com/categories/database/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://example.com/tags/sql/"}]},{"title":"Hello World","slug":"Hello World","date":"2022-07-08T11:23:05.000Z","updated":"2022-08-12T07:26:15.902Z","comments":true,"path":"2022/07/08/Hello World/","link":"","permalink":"http://example.com/2022/07/08/Hello%20World/","excerpt":"Hello World纪念一下 我的 blog 诞生！( ‘-ωก̀ )","text":"Hello World纪念一下 我的 blog 诞生！( ‘-ωก̀ )","categories":[{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/categories/Hello-World/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Tool","slug":"Tool","permalink":"http://example.com/categories/Tool/"},{"name":"常见问题","slug":"常见问题","permalink":"http://example.com/categories/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"database","slug":"database","permalink":"http://example.com/categories/database/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/categories/Hello-World/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"常见问题","slug":"常见问题","permalink":"http://example.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"sql","slug":"sql","permalink":"http://example.com/tags/sql/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}