<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git项目管理工具</title>
      <link href="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p><strong>Git项目管理工具</strong></p><span id="more"></span><p>学习 git 之前，我们需要先明白一个概念，版本控制</p><p><strong>版本控制</strong></p><p><strong>什么是版本控制</strong></p><p><strong>版本控制</strong>（Revision control）是一种在开发过程种用于管理我们对文件、目录或工程内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li><strong>实现跨区域多人协同开发</strong></li><li><strong>追钟和记载一个或者多个文件的历史记录</strong></li><li><strong>组织保护你的源代码和文档</strong></li><li><strong>统计工作量</strong></li><li><strong>并行开发、提高开发效率</strong></li><li><strong>跟踪记录整个软件的开发过程</strong></li><li><strong>减轻开发人员的负担，节省时间，同时降低认为错误</strong></li></ul><p>简单说就是用于管理多人协同开发项目的技术。</p><p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程种将会引入很多问题，如软件代码的一致性、软件内容冗余、软件过程的事务性、软件开发过程中的并发性、软件代码的安全性，以及软件的整合等问题。</p><p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们迫切需要一个版本控制工具！</p><p>多人开发就必须使用版本控制，都在代价会比较大！</p><p><strong>常见版本控制工具</strong></p><p><strong>主流的版本控制器有如下这些：</strong></p><ul><li><strong>Git</strong></li><li><strong>SVN（Subversion）</strong></li><li><strong>CVS（Concurrent Versions System）</strong></li><li><strong>VSS（Micorosoft Visual SourceSafe）</strong></li><li><strong>TFS（Team Foundation Server）</strong></li><li>Visual Studio Online</li></ul><p>版本控制产品非常的多（Preforce、Rational Clearcase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git和SVN</p><p><strong>版本控制分类</strong></p><p><strong>1、本地版本控制</strong></p><p>记录文件每次的更新，可以对每个版本做一个快照，或者是记录补丁文件，适合个人用，如 RCS。</p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/Git项目管理工具\git01.jpg" alt="0" style="zoom:33%;"></p><p><strong>2、集中版本控制 SVN</strong></p><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git02.jpg" alt="0" style="zoom: 33%;"></p><p>所有对的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不联网的话，用户就看不到历史版本，也无法切换版本验证问题或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><p><strong>3、分布式版本控制 Git</strong></p><p>每个人都拥有全部代码！安全隐患！</p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在联网时 push 到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地储存空间的占用。</p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git03.jpg" alt="0" style="zoom:33%;"></p><p><strong>Git 与 SVN 最主要的区别</strong></p><p>SVN 试集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作的，对网络宽带要求较高。</p><p>Git 是分布式版本控制器系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p>Git 是目前世界上最先进的分布式版本控制系统</p><p><strong>聊聊 Git 历史</strong></p><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p><p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991 - 2002年间)。到2002年，整个项目组开始启用一个专有的分布式版本控制系统BitKeeper来管理和维护代码。</p><p>到了2005年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。也就是后来的 Git！</p><p>Git 时目前世界上最先进的分布式版本控制系统。</p><p>Git 是免费、开源的，最初 Git 是为辅助 Linux 内核开发的，来代替BitKeeper！</p><p>Linux 和 Git 之父利纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p><p><strong>Git 环境配置</strong></p><p><strong>先卸载</strong></p><p>直接反安装即可、然后清理环境变量，环境变量只是为了全局使用而已！</p><p><strong>软件下载</strong> </p><p>打开【git官网】<a href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BD">https://git-scm.com/，下载</a> git 对应操作系统的版本。</p><p>官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p><p>下载对应的版本安装即可安装！</p><blockquote><p>安装：无脑下一步即可！安装完毕就可以使用了！</p></blockquote><p><strong>启动Git</strong></p><p>安装完成后在开始菜单中会有 Git 项，菜单下有3个程序：任意文件夹下右键耶可以看到对应的程序！</p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git04.jpg" alt="0"></p><p><strong>Git Bash：</strong>Unix 与 Linux 风格的命令行，使用最多，推荐最多</p><p><strong>Git CMD：</strong>Windows 风格的命令行</p><p><strong>Git GUI：</strong>图形界面的 Git ，不建议初学者使用，尽量先熟悉常用命令</p><p><strong>基本的 Linux 命令学习</strong></p><ol><li>cd：改变目录</li><li>cd ..：回退到上一个目录，直接cd进入默认的目录</li><li>pwd：显示当前所在的目录路径</li><li>ls(ll)：都是列出当前目录中的所有文件，只不ll（两个ll）列出的内容更加详细</li><li>touch：新建一个文件如 touch index.js 就会在当前目录下新建一个index.js文件</li><li>rm：删除一个文件，rm index.js 就会把 index.js文件删除</li><li>mkdir：新建一个目录，就是新建一个文件夹</li><li>rm -r：删除一个文件夹，rm -r src 删除src目录</li></ol><blockquote><p>rm -rf &#x2F; 切勿在Linux中尝试！删除电脑中全部文件！</p></blockquote><ol><li>mv 移动文件，mv index.jhtml src index.html 是我们要移动的文件，src是目标文件夹，当然，这样写，必须保证文件和目标文件夹在同一目录下</li><li>reset：重新初始化终端&#x2F;清屏</li><li>clear：清屏</li><li>history：查看命令历史</li><li>help：帮助</li><li>exit：推出</li><li>#表示注释</li></ol><p><strong>Git 配置</strong></p><p>查看配置 <em>git config -l</em> </p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git05.jpg" alt="0" style="zoom: 50%;"></p><p>查看不同级别的配置文件：</p><pre><code class="bash">#查看系统configgit config --system --list#查看当前用户（global）配置git config --global --list</code></pre><p><strong>Git 相关的配置文件</strong></p><p>​1. Git\etc\gitconfig：Git 安装目录下的 gitconfig  –system 系统级</p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git06.jpg" alt="0" style="zoom:50%;"></p><p>​2. C:\Users\Administrator.gitconfig 只适用当前登录用户的配置 –global 全局</p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git07.jpg" alt="0"></p><p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p><blockquote><p><strong>设置用户名与邮箱（用户标识，必要）</strong></p></blockquote><p>当你安装 Git 后首先要做的事情是设置你的用户名称和 e-mail 地址。这是非常重要的，因为每次 Git 提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><pre><code class="bash">git config --global user.name &quot;用户名&quot; #名称git config --global user.email &quot;邮箱&quot; #邮箱</code></pre><p>只需要做一次这个设置，如果你传递了 –global 选项，因为 Git 将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同名称或 e-mail 地址，你可以在该项目中运行该命令而不要 –global 选项。总之 –global 为全局配置，不加为某个项目的特定配置。</p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git08.jpg" alt="0" style="zoom: 67%;"></p><p><strong>Git 基本理论（核心）</strong></p><blockquote><p>工作领域</p></blockquote><p>Git 本地有三个工作领域：工作目录（Working Directory）、暂存区（Stage&#x2F;Index）、资源库（Repository 或 Git Directory）。如果在加上远程的 git 仓库（Remote Directory）就可以分为四个工作领域。文件在这四个区域之间的转换关系如下：</p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git09.jpg" alt="0" style="zoom:50%;"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中 HEAD 指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换本地三个区域确切的说应该是 git 仓库中 HEAD 指向的版本：</li></ul><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git10.jpg" alt="0" style="zoom:50%;"></p><ul><li>Directory：使用 Git 管理的一个目录，也就是一个仓库，包含我们的工作空间和 Git 的管理空间</li><li>WorkSpace：需要通过 Git 进行版本控制的目录和文件，这些目录和文件组成了工作空间</li><li>.git：存放 Git 管理信息的目录，初始化仓库的时候自动创建</li><li>Index&#x2F;Stage：暂存区，或者叫待提交更新区，在提交进入 repo 之前，我们把所有的更新放在暂存区</li><li>Local Repo：本地仓库，一个放在本地的版本库；HEAD会只是当前的开发分支（branch）</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存&#x2F;恢复 WorkSpace 中的临时状态</li></ul><blockquote><p>工作流程</p></blockquote><p>git 的工作流程一般是这样的：</p><ol><li>在工作目录中添加、修改文件</li><li>将需要进行版本管理的文件放入暂存区域</li><li>将暂存区域的文件提交到 git 仓库</li></ol><p>因此，git 管理的文件有三种状态：已修改（modified），已暂存（staged），已提交（committed）</p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git11.jpg" alt="0" style="zoom:50%;"></p><p><strong>Git 项目搭建</strong></p><blockquote><p>创建工作目录与常用指令</p></blockquote><p>工作目录（WorkSpace）一般就是希望 Git 帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git12.jpg" alt="0" style="zoom:50%;"></p><blockquote><p>本地仓库搭建</p></blockquote><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>1、创建全新的仓库，需要用 Git 管理的项目的根目录执行；</p><pre><code class="bash">#在当前目录新建一个 Git 代码库$ git init</code></pre><p>2、执行后可以看到，仅仅在项目目录多出了一个 .git 目录，关于版本等的所有信息都在这个目录里面。</p><blockquote><p>克隆远程仓库</p></blockquote><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！           </p><pre><code class="bash">#克隆一个项目和它的整个代码历史（版本信息）$ git clone [url]</code></pre><p>2、去 gitte 或者 github 上克隆一个测试！</p><p><strong>Git 文件操作</strong></p><blockquote><p>文件4种状态</p></blockquote><p>版本控制就是对文件的版本控制，要对文件进行修改，提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li><strong>Untracked</strong>：未跟踪，此文件在文件夹中，但并没有加入到 git 库，不参与版本控制。通过 git add 状态变为 Staged</li><li><strong>Unmodify</strong>：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致，这种类型的文件有两种去处，如果它被修改，而变为 Modified 。如果使用 git crm 移出版本库，则成为 Untracked 文件</li><li><strong>Modified</strong>：文件已修改，仅仅是修改，并没有进行其他的操作，这个文件也有两个去处，通过 git add 可进入暂存 Staged 状态，使用 git checkout 则丢弃修改过，返回到 unmodify 状态，这个 git checkout 即从库中取出文件，覆盖当前修改！</li><li><strong>Staged</strong>：暂存状态，执行 git commit 则将修改同步到库中，这时候库中的文件和本地文件又变为一致，文件为 Unmodify 状态。执行 git reset HEAD filename 取消暂存，文件状态为 Modified</li></ul><blockquote><p>查看文件状态</p></blockquote><p>上面说文件有4种状态，通过如下命令可以查看到文件状态：</p><pre><code class="bash">#查看指定文件状态git status [filename]#查看所有文件状态git status#添加所有文件到暂存区git add .#提交暂存区中的内容到本地仓库 -m 提交信息git commit -m &quot;消息内容&quot;</code></pre><blockquote><p>忽略文件</p></blockquote><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立 “gitignore” 文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略</li><li>可以使用 Linux 通配符。例如：星号（*）代表任意多个字符，问号（?）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,….}）代表可选的字符串等</li><li>如果名称的最前面有一个感叹号（!），标识列外规则，将不被忽略</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略</li><li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）</li></ol><pre><code>#为注释*.txt #忽略所有!lib.txt #但lib.txt除外/temp #仅忽略项目根目录下的TODO文件，不包括其他目录tempbuild/ #忽略build/目录下的所有文件doc/*.txt #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</code></pre><p><strong>使用码云</strong></p><blockquote><p>github是有墙的，比较慢，在国内的话，我们一般使用gitee，有时候会搭建gitlab服务器</p></blockquote><p>1、注册登录码云，完善个人信息</p><p>2、设置本机绑定SSH公钥，实现免密码登录！</p><pre><code class="bash">#进入 C:\Users\Administrator\.ssh 目录#生成公钥ssh-keygen</code></pre><p>3、将公钥信息public key 添加到码云账户中即可！</p><p>4、使用码云创建一个自己的仓库！</p><p><strong>IDEA 集成 Git</strong></p><p>1.新建项目，绑定 git</p><ul><li>将我们远程的 git 文件目录拷贝到项目中即可！</li></ul><p>2.修改文件，使用 IDEA 操作 git</p><p>3.提交测试</p><p><strong>说明：GIT 分支</strong></p><p>分支在 Git 中相对较难，分支就是科幻电影的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理问题了！</p><p>​    <img src="/2022/07/18/Git%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/git13.jpg" alt="0" style="zoom:50%;"></p><p>git 分支中常用指令：</p><pre><code class="bash"># 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><p>如果多个分支并行执行，就会导致我们代码不冲突，也就是同时存在多个版本！</p><p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！</p><p>master 主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的 dev 分支上工作，工作完后，比如上要发布，或者说 dev 分支代码稳定后可以合并到主分支 master 上来</p>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发常见问题</title>
      <link href="/2022/07/12/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/07/12/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>我们在做开发的时候经常会遇见各种各样的问题，分享一下我遇到的一些问题以及解决办法</p><span id="more"></span><p><strong>windows 系统启动服务时出现报错</strong></p><p>1.Windows启动服务出现错误“并非所有的功能被成功更改” 的问题</p><p>按 “Windows 徽标键+X”，启动 “Windows PowerShell（管理员）”，输入以下命令：</p><pre><code class="bash">Dism /Online /Cleanup-Image /ScanHealth</code></pre><p>这条命令将扫描全部系统文件并和官方系统文件对比，扫描计算机中的不一致情况</p><pre><code class="bash">Dism /Online /Cleanup-Image /CheckHealth</code></pre><p>这条命令必须在前一条命令执行完以后，发现系统文件有损坏时使用</p><pre><code class="bash">DISM /Online /Cleanup-image /RestoreHealth</code></pre><p>这条命令是把那些不同的系统文件还原成官方系统源文件</p><p>无论前三条命令是否可用，完成后重启，再键入以下命令：</p><pre><code class="bash">sfc /SCANNOW</code></pre><h4 id="maven-常见问题"><a href="#maven-常见问题" class="headerlink" title="maven 常见问题"></a>maven 常见问题</h4><p>有的时候需要将一些自己封装的包放入本地仓库进行程序打包，可以是由 mvn 指令将包放入本地仓库</p><pre><code class="bash">//将本地文件放入本地仓库，仓库的位置跟你本地的 settings.xml 配置有关mvn install:install-file -Dfile=D:\company\encrypt_sdk.jar -DgroupId=encrypt_sdk -DartifactId=encrypt_sdk -Dversion=1.0 -Dpackaging=jar</code></pre><p>idea maven 插件打包报错不知道怎么解决，可以尝试将依赖从本地仓库移除重新下载，或者使用 mvn 打包指令</p><pre><code class="bash">//mvn 打包进入调试模式，会有比较详细的报错信息，应该能帮助你找到问题mvn package -x</code></pre><p><strong>前端传参常见问题</strong></p><p>参数格式化（数组），前端请求后端 api 带数组参数比较特殊不做处理可能导致后端无法正常接收到参数</p><pre><code class="javascript">//vue axios请求paramsSerializer: params =&gt; &#123;  return qs.stringify(params, &#123; indices: false &#125;)&#125;//ajax 请求 添加traditional 请求参数为 true, 也可以将参数转换为 json 再传递$.ajax(&#123;    url: &#39;apiurl&#39;,    data: data[],    type: &#39;post&#39;,    traditional:true，    success: res =&gt; &#123;        //代码省略...    &#125;,    error: err =&gt; &#123;           //代码省略...    &#125;&#125;)</code></pre><p><strong>Cookie</strong></p><p>当浏览器存在 cookie 时向 api 发送请求会自动将 cookie 带入请求（统一域名）</p><p>注：特定情况下会自动将cookie带入请求头部</p><p><strong>依赖排除</strong></p><p>​例：由于 log4j 2.17 版本以下出现高危漏洞，springboot-stater 依赖整合了  log4j 依赖如果直接去除会导致项目无法运行，建议更换  2.17.1  版本</p><pre><code class="xml">&lt;!-- 2.17.0修复漏洞版本 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;    &lt;version&gt;2.17.0&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;    &lt;version&gt;2.17.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;    &lt;version&gt;2.17.0&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;</code></pre><p><strong>npm 清理缓存</strong></p><p>web前端可能由于网络波动造成下载超时，npm缓存未清理造成依赖下载失败，解决（清理 npm 缓存）</p><pre><code class="bash">npm cache clean --force              </code></pre><p>查看 npm 缓存的位置</p><pre><code class="bash">npm cache dir              </code></pre><p>可能由于版本问题无法执行上一条指令，可以尝试下面这条</p><pre><code class="bash">npm config list --json              </code></pre><h4 id="CMD指令"><a href="#CMD指令" class="headerlink" title="CMD指令"></a><strong>CMD指令</strong></h4><h5 id="CMD端口指令"><a href="#CMD端口指令" class="headerlink" title="CMD端口指令"></a><strong>CMD端口指令</strong></h5><p>查看端口（根据端口号）：</p><pre><code class="bash">netstat -aon|findstr &quot;端口号&quot;</code></pre><p>查看端口（全部）： </p><pre><code class="bash">netstat -ano</code></pre><p>杀死端口（根据pid）：</p><pre><code class="bash">taskkill /pid &quot;pid&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Postgresql数据库</title>
      <link href="/2022/07/11/Postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/07/11/Postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>Postgresql数据库是关系型数据库</p><p>下载地址： <a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</a></p><span id="more"></span><p><strong>WITH 查询</strong></p><p>​WITH查询是PostgreSQL支持的高级SQL特性之一，这一特性常称为CTE(Common Table Expressions)，WITH查询在复杂查询中定义一个辅助语句（可理解成在一个查询中定义的临时表），这一特性常用于复杂查询或递归查询应用场景</p><pre><code class="sql">with a as (select * from wp_dkbasedatainfo where xzqdm =&#39;650203&#39; )select * from a ,b where a.tbflqk=&#39;实地伪变化&#39;</code></pre><p>​WITH 查询的一个重要属性是 RECURSIVE，使用 RECURSIVE 属性可以引用自己的输出，从而实现递归，一般用于层次结构或树状结构的应用场景</p><p>例如，存在一张包含如下数据的表：</p><pre><code class="sql">id name fatherid1 中国 02 辽宁 13 山东 14 沈阳 25 大连 26 济南 37 和平区 48 沈河区 4</code></pre><p>使用PostgreSQL的WITH查询检索ID为7以及以上的所有父节点，如下：</p><pre><code class="sql">WITH RECURSIVE r AS ( SELECT * FROM test_area WHERE id = 7 UNION ALL SELECT test_area.* FROM test_area, r WHERE test_area.id = r.fatherid ) SELECT * FROM r ORDER BY id;</code></pre><p>查询结果如下：</p><pre><code class="sql">id | name | fatherid----+--------+---------- 1 | 中国 | 0 2 | 辽宁 | 1 4 | 沈阳 | 2 7 | 和平区 | 4(4 rows)</code></pre><p><strong>WITH RECURSIVE</strong></p><p>WITH 语句还可以通过增加 RECURSIVE 修饰符来引入它自己，从而实现递归</p><p>WITH RECURSIVE 一般用于处理逻辑上层次化或树状结构的数据，典型的使用场景是寻找直接及间接子结点</p><p>定义下面这样的表，存储每个区域（省、市、区）的 id，名字及上级区域的 id</p><pre><code class="sql">CREATE TABLE chinamap(  id INTEGER,  pid INTEGER,  name TEXT);</code></pre><p>需要查出某个省，比如湖北省，管辖的所有市及市辖地区，可以通过WITH RECURSIVE来实现，如下：</p><pre><code class="sql">WITH RECURSIVE result AS(  SELECCT    id,    name  FROM  chinamap  WHERE id = 11  UNION ALL  SELECT    origin.id,    result.name || &#39; &gt; &#39; || origin.name  FROM result  JOIN chinamap origin  ON origin.pid = result.id)SELECT  id,  nameFROM result;</code></pre><p>结果如下：</p><pre><code class="sql"> id  |           name           -----+--------------------------  11 | 湖北省 110 | 湖北省 &gt; 武汉市 120 | 湖北省 &gt; 孝感市 130 | 湖北省 &gt; 宜昌市 140 | 湖北省 &gt; 随州市 150 | 湖北省 &gt; 仙桃市 160 | 湖北省 &gt; 荆门市 170 | 湖北省 &gt; 枝江市 180 | 湖北省 &gt; 神农架市 111 | 湖北省 &gt; 武汉市 &gt; 武昌区 112 | 湖北省 &gt; 武汉市 &gt; 下城区 113 | 湖北省 &gt; 武汉市 &gt; 江岸区 114 | 湖北省 &gt; 武汉市 &gt; 江汉区 115 | 湖北省 &gt; 武汉市 &gt; 汉阳区 116 | 湖北省 &gt; 武汉市 &gt; 洪山区 117 | 湖北省 &gt; 武汉市 &gt; 青山区(16 rows)  </code></pre><p><strong>WITH RECURSIVE 执行过程</strong></p><p>从上面的例子可以看出，WITH RECURSIVE语句包含了两个部分</p><ul><li>non-recursive term（非递归部分），即上例中的union all前面部分</li><li>recursive term（递归部分），即上例中union all后面部分</li></ul><p>执行步骤如下：</p><ol><li>执行non-recursive term（如果使用的是union而非union all，则需对结果去重）其结果作为recursive term中对result的引用，同时将这部分结果放入临时的working table中</li><li>重复执行如下步骤，直到working table为空：用working table的内容替换递归的自引用，执行recursive term，（如果使用union而非union all，去除重复数据），并用该结果（如果使用union而非union all，则是去重后的结果）替换working table</li></ol><p>以上面的query为例，来看看具体过程：</p><p>1.执行：</p><pre><code class="sql">SELECT  id,  nameFROM chinamapWHERE id = 11</code></pre><p>结果集和 working table 为：</p><pre><code class="sql">11 | 湖北              </code></pre><p>2.执行：</p><pre><code class="sql">SELECT  origin.id,  result.name || &#39; &gt; &#39; || origin.nameFROM resultJOIN chinamap originON origin.pid = result.id</code></pre><p>结果集和 working table 为：</p><pre><code class="sql">110 | 湖北省 &gt; 武汉市120 | 湖北省 &gt; 孝感市130 | 湖北省 &gt; 宜昌市140 | 湖北省 &gt; 随州市150 | 湖北省 &gt; 仙桃市160 | 湖北省 &gt; 荆门市170 | 湖北省 &gt; 枝江市180 | 湖北省 &gt; 神农架市</code></pre><p>3.再次执行recursive query，结果集和working table为：   </p><pre><code class="sql">111 | 湖北省 &gt; 武汉市 &gt; 武昌区112 | 湖北省 &gt; 武汉市 &gt; 下城区113 | 湖北省 &gt; 武汉市 &gt; 江岸区114 | 湖北省 &gt; 武汉市 &gt; 江汉区115 | 湖北省 &gt; 武汉市 &gt; 汉阳区116 | 湖北省 &gt; 武汉市 &gt; 洪山区117 | 湖北省 &gt; 武汉市 &gt; 青山区</code></pre><p>4.继续执行recursive query，结果集和working table为空</p><p>5.结束递归，将前三个步骤的结果集合并，即得到最终的WITH RECURSIVE的结果集严格来讲，这个过程实现上是一个迭代的过程而非递归，不过RECURSIVE这个关键词是SQL标准委员会定立的，所以PostgreSQL也延用了RECURSIVE这一关键词</p><p><strong>WITH RECURSIVE 防止死循环</strong></p><p>​从上一节中可以看到，决定是否继续迭代的working table是否为空，如果它永不为空，则该CTE将陷入无限循环中</p><p>对于本身并不会形成循环引用的数据集，无段作特别处理而对于本身可能形成循环引用的数据集，则须通过SQL处理</p><p>​一种方式是使用UNION而非UNION ALL，从而每次recursive term的计算结果都会将已经存在的数据清除后再存入working table，使得working table最终会为空，从而结束迭代</p><p>​然而，这种方法并不总是有效的，因为有时可能需要这些重复数据同时UNION只能去除那些所有字段都完全一样的记录，而很有可能特定字段集相同的记录即应该被删除此时可以通过数组（单字段）或者ROW（多字段）记录已经访问过的记录，从而实现去重的目的</p><p><strong>WITH RECURSIVE 求最短路径</strong></p><p>定义如下表并存入每条边的权重</p><pre><code class="sql">CREATE TABLE graph(  id char,  neighbor char,  value integer);INSERT INTO graphVALUES(&#39;A&#39;, &#39;B&#39;, 3),(&#39;A&#39;, &#39;C&#39;, 5),(&#39;A&#39;, &#39;D&#39;, 4),(&#39;B&#39;, &#39;E&#39;, 8),(&#39;B&#39;, &#39;C&#39;, 4),(&#39;E&#39;, &#39;C&#39;, 7),(&#39;E&#39;,&#39;F&#39;, 10),(&#39;C&#39;, &#39;D&#39;, 3),(&#39;C&#39;, &#39;F&#39;, 6),(&#39;F&#39;,&#39;D&#39;, 5);   </code></pre><p>计算思路如下：</p><ul><li>因为是无向图，所以首先要将各条边的id和neighbor交换一次以方便后续计算</li><li>利用WITH RECURSIVE算出所有可能的路径并计算其总权重</li><li>因为该图有环，为避免无限循环，同时为了计算路径，将经过的结点存于数据中，当下一个结点已经在数据中时，说明该结点已被计算</li><li>最终可算出所有可能的路径及其总权重</li></ul><p>实现如下：    </p><pre><code class="sql"> WITH RECURSIVE edges AS (  SELECT id, neighbor, value FROM graph  UNION ALL  SELECT neighbor, id, value   FROM graph), all_path (id, neighbor, value, path, depth, cycle) AS (  SELECT    id, neighbor, value, ARRAY[id], 1, &#39;f&#39;::BOOLEAN  FROM edges  WHERE id = &#39;A&#39;  UNION ALL  SELECT    all_path.id,    edges.neighbor,    edges.value + all_path.value,    all_path.path || ARRAY[edges.id],    depth + 1,    edges.id = ANY(all_path.path)  FROM edges  JOIN all_path  ON all_path.neighbor = edges.id  AND NOT cycle), a_f AS (  SELECT    rank() over(order by value) AS rank,    path || neighbor AS path,    value,    depth  FROM all_path  WHERE neighbor = &#39;F&#39;)SELECT path, value, depthFROM a_fWHERE rank = 1;</code></pre><p><strong>WITH RECURSIVE 使用限制</strong></p><ul><li>如果在recursive term中使用LEFT JOIN，自引用必须在“左”边</li><li>如果在recursive term中使用RIGHT JOIN，自引用必须在“右”边</li><li>recursive term中不允许使用FULL JOIN</li><li>recursive term中不允许使用GROUP BY和HAVING</li><li>不允许在recursive term的WHERE语句的子查询中使用CTE的名字</li><li>不支持在recursive term中对CTE作aggregation</li><li>recursive term中不允许使用ORDER BY</li><li>LIMIT &#x2F; OFFSET不允许在recursive term中使用</li><li>FOR UPDATE不可在recursive term中使用</li><li>recursive term中SELECT后面不允许出现引用CTE名字的子查询</li><li>同时使用多个CTE表达式时，不允许多表达式之间互相访问（支持单向访问）</li><li>在recursive term中不允许使用FOR UPDATE</li></ul><p><strong>CTE 优缺点</strong></p><ul><li>可以使用递归 WITH RECURSIVE，从而实现其它方式无法实现或者不容易实现的查询</li><li>当不需要将查询结果被其它独立查询共享时，它比视图更灵活也更轻量</li><li>CTE只会被计算一次，且可在主查询中多次使用</li><li>CTE可极大提高代码可读性及可维护性</li><li>CTE不支持将主查询中where后的限制条件push down到CTE中，而普通的子查询支持</li></ul><p>2.数据库中的数据如果不存在则插入，存在则更新</p><pre><code class="sql">INSERT INTO test_postgre(id,name,InputTime,age)VALUES(&#39;1&#39;,&#39;postgre&#39;,&#39;2018-01-10 22:00:00&#39;,24)ON conflict(id) DO UPDATE SET name = &#39;postgreOk&#39;, InputTime =&#39;2018-02-22 12:00:00&#39;    </code></pre><p><strong>常用 SQL 语句</strong></p><pre><code class="sql">-- 如果表中存在了 id 这条数据则更新否则向表中插入数据INSERT INTO test_postgre(id,name,InputTime,age)VALUES(&#39;1&#39;,&#39;postgre&#39;,&#39;2018-01-10 22:00:00&#39;,24)ON conflict(id) DO UPDATE SET name = &#39;postgreOk&#39;, InputTime =&#39;2018-02-22 12:00:00&#39;-- 如果 a.title 为空则取 b.title 的值select coalesce(a.title,b.title) from ajoin b on a.pid = a.id-- 筛选 title 列为空的数据select * from awhere a.title is null-- 筛选 title 列为非空的数据select * from awhere a.title is not null-- case when 语句块的使用select (case     when fwxz = &#39;0&#39; then &#39;市场化商品房&#39;    when fwxz = &#39;1&#39; then &#39;动迁房&#39;    when fwxz = &#39;2&#39; then &#39;配套商品房&#39;    when fwxz = &#39;3&#39; then &#39;公共租赁住房&#39;    when fwxz = &#39;4&#39; then &#39;廉租住房&#39;    when fwxz = &#39;5&#39; then &#39;限价普通商品住房&#39;    when fwxz = &#39;6&#39; then &#39;经济适用住房&#39;    when fwxz = &#39;7&#39; then &#39;定销商品房&#39;    when fwxz = &#39;8&#39; then &#39;集资建房&#39;    when fwxz = &#39;9&#39; then &#39;福利房&#39;    when fwxz = &#39;10&#39; then &#39;保障性住房&#39;    when fwxz = &#39;11&#39; then &#39;房改房&#39;    when fwxz = &#39;12&#39; then &#39;自建房&#39;    when fwxz = &#39;99&#39; then &#39;其它&#39;    else fwxzend) as fwxz,count(*)from fwb_qjcg_hbgroup by fwxz-- 查询时去除重复的数据select distinct name,phone from user-- 更新返回更新后列的数据update &quot;user&quot; set username = &#39;aa&#39; returning username-- 插入表中某列的数据返回插入后的数据insert into &quot;user&quot;(username) values(&#39;张三&#39;) returning username-- unnest 函数将输入的数组转换成一个表,这个表的每一列都代表相应的一个数组中的元素select &#39;张三&#39; as name ,unnest(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) as course-- with ordinality 用于给返回的结果集增加一个整数列，这个整数列从1开始，并且按1递增-- 注： with ordinality 必须使用在from子句中，且要紧跟在函数后面使用！select * from unnest(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) with ordinality-- round 函数用于把数值字段舍入为指定的小数位数-- 注：使用 round 函数时注意统一字段类型，可使用 as 或者 &#39;::&#39; 转换字段类型select round(12.743874,2)-- random() 函数可以获取随机数，固定公式 random() * (num1 - num2)+num2select random() * (100-1) + 1 --获取 1 ~ 100 以内的随机数-- generate_series() 函数可以按不同的规则产生一系列的填充数据-- generate_series(start, stop) 获取100个 1 ~ 100 以内的随机数select (random() * (100-1) + 1) as num from generate_series(1,100)-- generate_series(start, stop, step) 生成一个数值序列，从start 到 stop，步进为stepselect generate_series(10,1,-1)-- generate_series(start, stop, step_interval) 生成一个数值序列，从start 到 stop，步进为stepselect generate_series(now(), now() + &#39;7 days&#39;, &#39;1 day&#39;)-- 创建序列create sequence seq_user increment by 1 minvalue 1 no maxvalue start with 1-- nextval() 函数递增序列并返回新值select nextval(seq_user)</code></pre>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/08/Hello%20World/"/>
      <url>/2022/07/08/Hello%20World/</url>
      
        <content type="html"><![CDATA[<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>纪念一下 我的 blog 诞生</p>]]></content>
      
      
      <categories>
          
          <category> Hello World </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello World </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
