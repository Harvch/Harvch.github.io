<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开发常见问题</title>
      <link href="/2022/07/12/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2022/07/12/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>我们在做开发的时候经常会遇见各种各样的问题，分享一下我遇到的一些问题以及解决办法</p><span id="more"></span><p><strong>windows 系统启动服务时出现报错</strong></p><p>1.Windows启动服务出现错误“并非所有的功能被成功更改” 的问题</p><p>按 “Windows 徽标键+X”，启动 “Windows PowerShell（管理员）”，输入以下命令：</p><pre><code>Dism /Online /Cleanup-Image /ScanHealth</code></pre><p>这条命令将扫描全部系统文件并和官方系统文件对比，扫描计算机中的不一致情况</p><pre><code class="shell">Dism /Online /Cleanup-Image /CheckHealth</code></pre><p>这条命令必须在前一条命令执行完以后，发现系统文件有损坏时使用</p><pre><code class="shell">DISM /Online /Cleanup-image /RestoreHealth</code></pre><p>这条命令是把那些不同的系统文件还原成官方系统源文件</p><p>无论前三条命令是否可用，完成后重启，再键入以下命令：</p><pre><code class="shell">sfc /SCANNOW</code></pre><h4 id="maven-常见问题"><a href="#maven-常见问题" class="headerlink" title="maven 常见问题"></a>maven 常见问题</h4><p>有的时候需要将一些自己封装的包放入本地仓库进行程序打包，可以是由 mvn 指令将包放入本地仓库</p><pre><code class="shell">//将本地文件放入本地仓库，仓库的位置跟你本地的 settings.xml 配置有关mvn install:install-file -Dfile=D:\company\encrypt_sdk.jar -DgroupId=encrypt_sdk -DartifactId=encrypt_sdk -Dversion=1.0 -Dpackaging=jar</code></pre><p>idea maven 插件打包报错不知道怎么解决，可以尝试将依赖从本地仓库移除重新下载，或者使用 mvn 打包指令</p><pre><code class="shell">//mvn 打包进入调试模式，会有比较相信的报错信息，应该能帮助你找到问题mvn package -x</code></pre><p><strong>前端传参常见问题</strong></p><p>参数格式化（数组），前端请求后端 api 带数组参数比较特殊不做处理可能导致后端无法正常接收到参数</p><pre><code class="javascript">//vue axios请求paramsSerializer: params =&gt; &#123;  return qs.stringify(params, &#123; indices: false &#125;)&#125;//ajax 请求 添加traditional 请求参数为 true, 也可以将参数转换为 json 再传递$.ajax(&#123;    url: &#39;apiurl&#39;,    data: data[],    type: &#39;post&#39;,    traditional:true，    success: res =&gt; &#123;        //代码省略...    &#125;,    error: err =&gt; &#123;           //代码省略...    &#125;&#125;)</code></pre><p><strong>Cookie</strong></p><p>当浏览器存在 cookie 时向 api 发送请求会自动将 cookie 带入请求（统一域名）</p><p>注：特定情况下会自动将cookie带入请求头部</p><p><strong>依赖排除</strong></p><p>​例：由于 log4j 2.17 版本以下出现高危漏洞，springboot-stater 依赖整合了  log4j 依赖如果直接去除会导致项目无法运行，建议更换  2.17.1  版本</p><pre><code class="xml">&lt;!-- 2.17.0修复漏洞版本 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;    &lt;version&gt;2.17.0&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;    &lt;version&gt;2.17.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;    &lt;version&gt;2.17.0&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;</code></pre><p><strong>npm 清理缓存</strong></p><p>web前端可能由于网络波动造成下载超时，npm缓存未清理造成依赖下载失败，解决（清理 npm 缓存）</p><pre><code class="shell">npm cache clean --force              </code></pre><p>查看 npm 缓存的位置</p><pre><code class="shell">npm cache dir              </code></pre><p>可能由于版本问题无法执行上一条指令，可以尝试下面这条</p><pre><code class="shell">npm config list --json              </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 常见问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Postgresql数据库</title>
      <link href="/2022/07/11/Postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/07/11/Postgresql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>Postgresql数据库是关系型数据库</p><p>下载地址： <a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</a></p><span id="more"></span><p><strong>WITH 查询</strong></p><p>​WITH查询是PostgreSQL支持的高级SQL特性之一，这一特性常称为CTE(Common Table Expressions)，WITH查询在复杂查询中定义一个辅助语句（可理解成在一个查询中定义的临时表），这一特性常用于复杂查询或递归查询应用场景</p><pre><code class="sql">with a as (select * from wp_dkbasedatainfo where xzqdm =&#39;650203&#39; )select * from a ,b where a.tbflqk=&#39;实地伪变化&#39;</code></pre><p>​WITH 查询的一个重要属性是 RECURSIVE，使用 RECURSIVE 属性可以引用自己的输出，从而实现递归，一般用于层次结构或树状结构的应用场景</p><p>例如，存在一张包含如下数据的表：</p><pre><code class="sql">id name fatherid1 中国 02 辽宁 13 山东 14 沈阳 25 大连 26 济南 37 和平区 48 沈河区 4</code></pre><p>使用PostgreSQL的WITH查询检索ID为7以及以上的所有父节点，如下：</p><pre><code class="sql">WITH RECURSIVE r AS ( SELECT * FROM test_area WHERE id = 7 UNION ALL SELECT test_area.* FROM test_area, r WHERE test_area.id = r.fatherid ) SELECT * FROM r ORDER BY id;</code></pre><p>查询结果如下：</p><pre><code class="sql">id | name | fatherid----+--------+---------- 1 | 中国 | 0 2 | 辽宁 | 1 4 | 沈阳 | 2 7 | 和平区 | 4(4 rows)</code></pre><p><strong>WITH RECURSIVE</strong></p><p>WITH 语句还可以通过增加 RECURSIVE 修饰符来引入它自己，从而实现递归</p><p>WITH RECURSIVE 一般用于处理逻辑上层次化或树状结构的数据，典型的使用场景是寻找直接及间接子结点</p><p>定义下面这样的表，存储每个区域（省、市、区）的 id，名字及上级区域的 id</p><pre><code class="sql">CREATE TABLE chinamap(  id INTEGER,  pid INTEGER,  name TEXT);</code></pre><p>需要查出某个省，比如湖北省，管辖的所有市及市辖地区，可以通过WITH RECURSIVE来实现，如下：</p><pre><code class="sql">WITH RECURSIVE result AS(  SELECCT    id,    name  FROM  chinamap  WHERE id = 11  UNION ALL  SELECT    origin.id,    result.name || &#39; &gt; &#39; || origin.name  FROM result  JOIN chinamap origin  ON origin.pid = result.id)SELECT  id,  nameFROM result;</code></pre><p>结果如下：</p><pre><code class="sql"> id  |           name           -----+--------------------------  11 | 湖北省 110 | 湖北省 &gt; 武汉市 120 | 湖北省 &gt; 孝感市 130 | 湖北省 &gt; 宜昌市 140 | 湖北省 &gt; 随州市 150 | 湖北省 &gt; 仙桃市 160 | 湖北省 &gt; 荆门市 170 | 湖北省 &gt; 枝江市 180 | 湖北省 &gt; 神农架市 111 | 湖北省 &gt; 武汉市 &gt; 武昌区 112 | 湖北省 &gt; 武汉市 &gt; 下城区 113 | 湖北省 &gt; 武汉市 &gt; 江岸区 114 | 湖北省 &gt; 武汉市 &gt; 江汉区 115 | 湖北省 &gt; 武汉市 &gt; 汉阳区 116 | 湖北省 &gt; 武汉市 &gt; 洪山区 117 | 湖北省 &gt; 武汉市 &gt; 青山区(16 rows)  </code></pre><p><strong>WITH RECURSIVE 执行过程</strong></p><p>从上面的例子可以看出，WITH RECURSIVE语句包含了两个部分</p><ul><li>non-recursive term（非递归部分），即上例中的union all前面部分</li><li>recursive term（递归部分），即上例中union all后面部分</li></ul><p>执行步骤如下：</p><ol><li>执行non-recursive term（如果使用的是union而非union all，则需对结果去重）其结果作为recursive term中对result的引用，同时将这部分结果放入临时的working table中</li><li>重复执行如下步骤，直到working table为空：用working table的内容替换递归的自引用，执行recursive term，（如果使用union而非union all，去除重复数据），并用该结果（如果使用union而非union all，则是去重后的结果）替换working table</li></ol><p>以上面的query为例，来看看具体过程：</p><p>1.执行：</p><pre><code class="sql">SELECT  id,  nameFROM chinamapWHERE id = 11</code></pre><p>结果集和 working table 为：</p><pre><code class="sql">11 | 湖北              </code></pre><p>2.执行：</p><pre><code class="sql">SELECT  origin.id,  result.name || &#39; &gt; &#39; || origin.nameFROM resultJOIN chinamap originON origin.pid = result.id</code></pre><p>结果集和 working table 为：</p><pre><code class="sql">110 | 湖北省 &gt; 武汉市120 | 湖北省 &gt; 孝感市130 | 湖北省 &gt; 宜昌市140 | 湖北省 &gt; 随州市150 | 湖北省 &gt; 仙桃市160 | 湖北省 &gt; 荆门市170 | 湖北省 &gt; 枝江市180 | 湖北省 &gt; 神农架市</code></pre><p>3.再次执行recursive query，结果集和working table为：   </p><pre><code class="sql">111 | 湖北省 &gt; 武汉市 &gt; 武昌区112 | 湖北省 &gt; 武汉市 &gt; 下城区113 | 湖北省 &gt; 武汉市 &gt; 江岸区114 | 湖北省 &gt; 武汉市 &gt; 江汉区115 | 湖北省 &gt; 武汉市 &gt; 汉阳区116 | 湖北省 &gt; 武汉市 &gt; 洪山区117 | 湖北省 &gt; 武汉市 &gt; 青山区</code></pre><p>4.继续执行recursive query，结果集和working table为空</p><p>5.结束递归，将前三个步骤的结果集合并，即得到最终的WITH RECURSIVE的结果集严格来讲，这个过程实现上是一个迭代的过程而非递归，不过RECURSIVE这个关键词是SQL标准委员会定立的，所以PostgreSQL也延用了RECURSIVE这一关键词</p><p><strong>WITH RECURSIVE 防止死循环</strong></p><p>​从上一节中可以看到，决定是否继续迭代的working table是否为空，如果它永不为空，则该CTE将陷入无限循环中</p><p>对于本身并不会形成循环引用的数据集，无段作特别处理而对于本身可能形成循环引用的数据集，则须通过SQL处理</p><p>​一种方式是使用UNION而非UNION ALL，从而每次recursive term的计算结果都会将已经存在的数据清除后再存入working table，使得working table最终会为空，从而结束迭代</p><p>​然而，这种方法并不总是有效的，因为有时可能需要这些重复数据同时UNION只能去除那些所有字段都完全一样的记录，而很有可能特定字段集相同的记录即应该被删除此时可以通过数组（单字段）或者ROW（多字段）记录已经访问过的记录，从而实现去重的目的</p><p><strong>WITH RECURSIVE 求最短路径</strong></p><p>定义如下表并存入每条边的权重</p><pre><code class="sql">CREATE TABLE graph(  id char,  neighbor char,  value integer);INSERT INTO graphVALUES(&#39;A&#39;, &#39;B&#39;, 3),(&#39;A&#39;, &#39;C&#39;, 5),(&#39;A&#39;, &#39;D&#39;, 4),(&#39;B&#39;, &#39;E&#39;, 8),(&#39;B&#39;, &#39;C&#39;, 4),(&#39;E&#39;, &#39;C&#39;, 7),(&#39;E&#39;,&#39;F&#39;, 10),(&#39;C&#39;, &#39;D&#39;, 3),(&#39;C&#39;, &#39;F&#39;, 6),(&#39;F&#39;,&#39;D&#39;, 5);   </code></pre><p>计算思路如下：</p><ul><li>因为是无向图，所以首先要将各条边的id和neighbor交换一次以方便后续计算</li><li>利用WITH RECURSIVE算出所有可能的路径并计算其总权重</li><li>因为该图有环，为避免无限循环，同时为了计算路径，将经过的结点存于数据中，当下一个结点已经在数据中时，说明该结点已被计算</li><li>最终可算出所有可能的路径及其总权重</li></ul><p>实现如下：    </p><pre><code class="sql"> WITH RECURSIVE edges AS (  SELECT id, neighbor, value FROM graph  UNION ALL  SELECT neighbor, id, value   FROM graph), all_path (id, neighbor, value, path, depth, cycle) AS (  SELECT    id, neighbor, value, ARRAY[id], 1, &#39;f&#39;::BOOLEAN  FROM edges  WHERE id = &#39;A&#39;  UNION ALL  SELECT    all_path.id,    edges.neighbor,    edges.value + all_path.value,    all_path.path || ARRAY[edges.id],    depth + 1,    edges.id = ANY(all_path.path)  FROM edges  JOIN all_path  ON all_path.neighbor = edges.id  AND NOT cycle), a_f AS (  SELECT    rank() over(order by value) AS rank,    path || neighbor AS path,    value,    depth  FROM all_path  WHERE neighbor = &#39;F&#39;)SELECT path, value, depthFROM a_fWHERE rank = 1;</code></pre><p><strong>WITH RECURSIVE 使用限制</strong></p><ul><li>如果在recursive term中使用LEFT JOIN，自引用必须在“左”边</li><li>如果在recursive term中使用RIGHT JOIN，自引用必须在“右”边</li><li>recursive term中不允许使用FULL JOIN</li><li>recursive term中不允许使用GROUP BY和HAVING</li><li>不允许在recursive term的WHERE语句的子查询中使用CTE的名字</li><li>不支持在recursive term中对CTE作aggregation</li><li>recursive term中不允许使用ORDER BY</li><li>LIMIT &#x2F; OFFSET不允许在recursive term中使用</li><li>FOR UPDATE不可在recursive term中使用</li><li>recursive term中SELECT后面不允许出现引用CTE名字的子查询</li><li>同时使用多个CTE表达式时，不允许多表达式之间互相访问（支持单向访问）</li><li>在recursive term中不允许使用FOR UPDATE</li></ul><p><strong>CTE 优缺点</strong></p><ul><li>可以使用递归 WITH RECURSIVE，从而实现其它方式无法实现或者不容易实现的查询</li><li>当不需要将查询结果被其它独立查询共享时，它比视图更灵活也更轻量</li><li>CTE只会被计算一次，且可在主查询中多次使用</li><li>CTE可极大提高代码可读性及可维护性</li><li>CTE不支持将主查询中where后的限制条件push down到CTE中，而普通的子查询支持</li></ul><p>2.数据库中的数据如果不存在则插入，存在则更新</p><pre><code class="sql">INSERT INTO test_postgre(id,name,InputTime,age)VALUES(&#39;1&#39;,&#39;postgre&#39;,&#39;2018-01-10 22:00:00&#39;,24)ON conflict(id) DO UPDATE SET name = &#39;postgreOk&#39;, InputTime =&#39;2018-02-22 12:00:00&#39;    </code></pre><p><strong>常用 SQL 语句</strong></p><pre><code class="sql">-- 如果表中存在了 id 这条数据则更新否则向表中插入数据INSERT INTO test_postgre(id,name,InputTime,age)VALUES(&#39;1&#39;,&#39;postgre&#39;,&#39;2018-01-10 22:00:00&#39;,24)ON conflict(id) DO UPDATE SET name = &#39;postgreOk&#39;, InputTime =&#39;2018-02-22 12:00:00&#39;-- 如果 a.title 为空则取 b.title 的值select coalesce(a.title,b.title) from ajoin b on a.pid = a.id-- 筛选 title 列为空的数据select * from awhere a.title is null-- 筛选 title 列为非空的数据select * from awhere a.title is not null-- case when 语句块的使用select (case     when fwxz = &#39;0&#39; then &#39;市场化商品房&#39;    when fwxz = &#39;1&#39; then &#39;动迁房&#39;    when fwxz = &#39;2&#39; then &#39;配套商品房&#39;    when fwxz = &#39;3&#39; then &#39;公共租赁住房&#39;    when fwxz = &#39;4&#39; then &#39;廉租住房&#39;    when fwxz = &#39;5&#39; then &#39;限价普通商品住房&#39;    when fwxz = &#39;6&#39; then &#39;经济适用住房&#39;    when fwxz = &#39;7&#39; then &#39;定销商品房&#39;    when fwxz = &#39;8&#39; then &#39;集资建房&#39;    when fwxz = &#39;9&#39; then &#39;福利房&#39;    when fwxz = &#39;10&#39; then &#39;保障性住房&#39;    when fwxz = &#39;11&#39; then &#39;房改房&#39;    when fwxz = &#39;12&#39; then &#39;自建房&#39;    when fwxz = &#39;99&#39; then &#39;其它&#39;    else fwxzend) as fwxz,count(*)from fwb_qjcg_hbgroup by fwxz-- 查询时去除重复的数据select distinct name,phone from user-- 更新返回更新后列的数据update &quot;user&quot; set username = &#39;aa&#39; returning username-- 插入表中某列的数据返回插入后的数据insert into &quot;user&quot;(username) values(&#39;张三&#39;) returning username-- unnest 函数将输入的数组转换成一个表,这个表的每一列都代表相应的一个数组中的元素select &#39;张三&#39; as name ,unnest(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) as course-- with ordinality 用于给返回的结果集增加一个整数列，这个整数列从1开始，并且按1递增-- 注： with ordinality 必须使用在from子句中，且要紧跟在函数后面使用！select * from unnest(array[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]) with ordinality-- round 函数用于把数值字段舍入为指定的小数位数-- 注：使用 round 函数时注意统一字段类型，可使用 as 或者 &#39;::&#39; 转换字段类型select round(12.743874,2)-- random() 函数可以获取随机数，固定公式 random() * (num1 - num2)+num2select random() * (100-1) + 1 --获取 1 ~ 100 以内的随机数-- generate_series() 函数可以按不同的规则产生一系列的填充数据-- generate_series(start, stop) 获取100个 1 ~ 100 以内的随机数select (random() * (100-1) + 1) as num from generate_series(1,100)-- generate_series(start, stop, step) 生成一个数值序列，从start 到 stop，步进为stepselect generate_series(10,1,-1)-- generate_series(start, stop, step_interval) 生成一个数值序列，从start 到 stop，步进为stepselect generate_series(now(), now() + &#39;7 days&#39;, &#39;1 day&#39;)-- 创建序列create sequence seq_user increment by 1 minvalue 1 no maxvalue start with 1-- nextval() 函数递增序列并返回新值select nextval(seq_user)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/07/08/Hello%20World/"/>
      <url>/2022/07/08/Hello%20World/</url>
      
        <content type="html"><![CDATA[<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>纪念一下 我的 blog 诞生</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
